# SimpleSingleCell是基于EMBL-EBI的scater包和SingleCellExperiment对象进行单细胞数据分析的

#==============================================================================================
#
#             0.Analyzing single-cell RNA sequencing data from droplet-based protocols
#
#==============================================================================================

# This workflow will adapt many of the previous concepts to analysis of droplet-based scRNA-seq data, using the 
# publicly available dataset of 4000 peripheral blood mononuclear cells generated by 10X Genomics (Zheng et al. 2017). 
# It will focus on the modifications required to handle cell calling, even lower counts and no spike-ins.

######################################### Overview ##########################################
# 可以在10X的官网“https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/pbmc4k”
# 下载数据

####################################### Setting up the data #######################################

#----------------------# Reading in a sparse matrix 读取数据（稀疏矩阵） #----------------------#
## We load in the raw count matrix using the read10xCounts() function from the DropletUtils package. 
## This will create a SingleCellExperiment object where each column corresponds to a cell barcode.
untar("pbmc4k_raw_gene_bc_matrices.tar.gz", exdir="pbmc4k")   # 这一步可以省略了
setwd('/Users/mijiarui/Nature_Biotechnology_Paper/simpleSingleCell')
getwd()
dir('/Users/mijiarui/Nature_Biotechnology_Paper/simpleSingleCell/pbmc4k/raw_gene_bc_matrices/GRCh38')  # 我们看到标准的droplet-based 方法得到的下机文件
## 我们看到10X的数据解压以后是一个文件夹，进入文件夹有三个文件分别是“barcodes.tsv", "genes.tsc", "matrix.mtx"
## 一般10X的数据可以使用Seurat(适合大量细胞)，当然在细胞数有限的情况下考虑使用SingleCellExperiment对象
## 和Scater包也是可以一样处理的，在这里我们使用scater
library(DropletUtils)
fname <- "pbmc4k/raw_gene_bc_matrices/GRCh38"
sce <- read10xCounts(fname, col.names=TRUE) # 注意我们读入数据就直接构建了一个SingleCellExperiment对象
sce # assays里面只有counts一个slots

## Here, each count represents the number of unique molecular identifiers (UMIs) assigned to a gene 
## for a cell barcode. Note that the counts are loaded as a sparse matrix object - specifically, a 
## dgCMatrix instance from the Matrix package. This avoids allocating memory to hold zero counts, 
## which is highly memory-efficient for low-coverage scRNA-seq data.
## 一般10X的方法是和UMI序列一起配合使用的。一般来讲droplet-based methods是没有spike-in RNA的，这个数据也是典型的UMI数据
class(counts(sce))  # Matrix包中的dgCMatrix类型，属于一个稀疏矩阵。

#----------------------# Annotating the rows 数据预处理，对基因进行注释 #----------------------#
## We relabel the rows with the gene symbols for easier reading. This is done using the  
## uniquifyFeatureNames() function, which ensures uniqueness in the case of duplicated or missing 
## symbols. 这个uniquifyFeatureNames函数是来自scater包的。
library(scater)
head(rowData(sce)); length(rowData(sce)$ID)
rownames(sce) <- uniquifyFeatureNames(rowData(sce)$ID, rowData(sce)$Symbol)
head(rownames(sce))

## We also identify the chromosomal location for each gene. The mitochondrial location is particularly 
## useful for later quality control.
library(EnsDb.Hsapiens.v86)
str(EnsDb.Hsapiens.v86)
??ensembldb  # 对于这种注释包，建议查看这个帮助文档
ls('package:EnsDb.Hsapiens.v86')
location <- mapIds(EnsDb.Hsapiens.v86, keys=rowData(sce)$ID, 
                   column="SEQNAME", keytype="GENEID")
table(location) # 查看一下染色体的名字，尤其是注意一下线粒体基因是如何注释的，在这里是MT
rowData(sce)$CHR <- location
summary(location=="MT")


#################################### Calling cells from empty droplets 去除空微滴 ####################################
# An interesting aspect of droplet-based data is that we have no prior knowledge about which droplets 
# (i.e., cell barcodes) actually contain cells, and which are empty. Thus, we need to call cells from 
# empty droplets based on the observed expression profiles. This is not entirely straightforward as 
# empty droplets can contain ambient (i.e., extracellular) RNA that can be captured and sequenced. An 
# examination of the distribution of total counts suggests a fairly sharp transition between barcodes 
# with large and small total counts (Figure 1), probably corresponding to cell-containing and empty 
# droplets respectively.
# Droplet-based方法相比Fludigm的方法有一个缺陷，就是你无法通过肉眼来观察那些droplet是有细胞（正常细胞的），
# 所以我们常规通过计算每个droplet检测到的counts数量来评估这个droplet能不能用
bcrank <- barcodeRanks(counts(sce)) # 这个函数计算barcode rank统计量，找到统计值的knee和inflection point（拐点）
str(bcrank)

# Only showing unique points for plotting speed.
uniq <- !duplicated(bcrank$rank)
length(bcrank$rank[uniq])  
par(mfrow = c(1,1))
plot(bcrank$rank[uniq], bcrank$total[uniq], log="xy",   # 注意横纵坐标的数值
     xlab="Rank", ylab="Total UMI count", cex.lab=1.2,
     main = 'Total UMI count for each barcode in the PBMC dataset, plotted against its rank (in decreasing order of total counts)')

abline(h=bcrank$inflection, col="darkgreen", lty=2)
abline(h=bcrank$knee, col="dodgerblue", lty=2)

legend("bottomleft", legend=c("Inflection", "Knee"), 
       col=c("darkgreen", "dodgerblue"), lty=2, cex=1.2)


# We use the emptyDrops() function to test whether the expression profile for each cell barcode is 
# significantly different from the ambient pool (Lun et al. 2018). Any significant deviation indicates 
# that the barcode corresponds to a cell-containing droplet. We call cells at a false discovery rate 
# (FDR) of 1%, meaning that no more than 1% of our called barcodes should be empty droplets on average.
# 使用emptyDrops()函数来识别异常细胞
set.seed(100)
e.out <- emptyDrops(counts(sce))
dim(e.out)
head(e.out)
str(e.out)
table(e.out@listData$FDR)
sum(e.out$FDR <= 0.01, na.rm=TRUE)

# emptyDrops() computes Monte Carlo p-values, so it is important to set the random seed to obtain 
# reproducible results. The number of Monte Carlo iterations also determines the lower bound for 
# the _p_values. If any non-significant barcodes are TRUE for Limited, we may need to increase the 
# number of iterations to ensure that they can be detected.
table(Sig=e.out$FDR <= 0.01, Limited=e.out$Limited)
# We then subset our SingleCellExperiment object to retain only the detected cells.
# using which() to automatically remove NAs.
sce <- sce[,which(e.out$FDR <= 0.01)]
## emptyDrops() assumes that cell barcodes with total UMI counts below a certain threshold (default 
## of 100) correspond to empty droplets, and uses them to estimate the ambient expression profile. By 
## definition, these barcodes cannot be cell-containing droplets and are excluded from the hypothesis 
## testing, hence the NAs in the output.  
## 即emptyDrop默认单个细胞UMI数小于特定阈值（默认是100）为empty cell


#################################### Quality control on the cells 基于细胞的QC步骤 ####################################
# The previous step only distinguishes cells from empty droplets, but makes no statement about the 
# quality of the cells. It is entirely possible for droplets to contain damaged or dying cells, which 
# need to be removed prior to downstream analysis. We compute some QC metrics using 
# calculateQCMetrics() (McCarthy et al. 2017) and examine their distributions in Figure 2.
# 也就是说上面一步只是排除了empty droplet，但是对于damaged或者dying cell，并没有处理干净
str(sce)
sce <- calculateQCMetrics(sce, feature_controls=list(Mito=which(location=="MT")))
str(sce)  # 我们看到经过calculateQCMetrics后，增加了大量colData和elementMetadata(listData)的内容
par(mfrow=c(1,3))  # 这波操作和Seurat一模一样
hist(sce$log10_total_counts, breaks=20, col="grey80",    # UMI的分布
     xlab="Log-total UMI count")
hist(sce$log10_total_features_by_counts, breaks=20, col="grey80",   # 检测到的gene分布
     xlab="Log-total number of expressed features")
hist(sce$pct_counts_Mito, breaks=20, col="grey80",   # 线粒体基因百分比的分布
     xlab="Proportion of reads in mitochondrial genes")

# Ideally, we would remove cells with low library sizes or total number of expressed features as 
# described previously. However, this would likely remove cell types with low RNA content, 
# especially in a heterogeneous PBMC population with many different cell types. Thus, we use a more 
# relaxed strategy and only remove cells with large mitochondrial proportions, using it as a proxy (代理)
# for cell damage. (Keep in mind that droplet-based datasets usually do not have spike-in RNA.)
# 为了减少排除那些本身RNA表达量就很低的细胞，我们仅仅根据线粒体基因表达百分比来进行过滤。
high.mito <- isOutlier(sce$pct_counts_Mito, nmads=3, type="higher")
sce <- sce[,!high.mito]
summary(high.mito)

## The above justification for using a more relaxed filter is largely retrospective. In practice, 
## we may not know a priori the degree of population heterogeneity and whether it manifests in the 
## QC metrics. We recommend performing the analysis first with a stringent QC filter, and then 
## relaxing it based on further diagnostics (see here for an example). This is motivated by the fact 
## that low-quality cells can often yield misleading results, clustering separately from other cells; 
## containing genes that appear to be strongly “upregulated” due to the presence of very small size 
## factors; containing genes that are strongly downregulated due to the loss of RNA upon cell damage; 
## and distorting the characterization of population heterogeneity during variance estimation or PCA.
## Aaron建议我们在进行数据过滤的时候采取先紧后松的策略，也就是说我们首先进行严格的QC，这样防止后面差异基因，
## PCA，细胞异质性分析产生误差。这边Aaron采取比较宽松的过滤是回顾性的重新调整。

##################################### Examining gene expression 查看基因表达量 #####################################
# The average expression of each gene is much lower here compared to the previous datasets (Figure 3). 
# This is due to the reduced coverage per cell when thousands of cells are multiplexed together for 
# sequencing. 我们看到基因的表达量非常低
ave <- calcAverage(sce)
rowData(sce)$AveCount <- ave
par(mfrow = c(1,1))
hist(log10(ave), col="grey80")

# The set of most highly expressed genes is dominated by ribosomal protein and mitochondrial genes (Figure 4), as expected.
plotHighestExprs(sce)  # 比较耗时。
## For each feature, each bar represents the percentage assigned to that feature for a single cell, while the circle represents 
## the average across all cells. Bars are coloured by the total number of expressed features in each cell.

################################## Normalizing for cell-specific biases 去除混杂因素(测序文库大小) ################################
# We apply the deconvolution method to compute size factors for all cells (Lun, Bach, and Marioni 2016). 
# We perform some pre-clustering to break up obvious clusters and avoid pooling cells that are very 
# different. 计算每个细胞的size factor，但是事先对细胞进行cluster，以排除因为明显的cluster造成了误差
# 使用了scran包中的quickCluster函数，Cluster similar cells based on rank correlations in their gene expression profiles；
# 其中cluster的method有两个，一个是hclust，另一个是igraph(shared nearest neighbor graph)；对细胞进行
# 一个最粗略的cluster。
library(scran)
clusters <- quickCluster(sce, method="igraph", min.mean=0.1,
                         irlba.args=list(maxit=1000)) # for convergence.
table(clusters)

sce <- computeSumFactors(sce, min.mean=0.1, cluster=clusters)
summary(sizeFactors(sce))

# The size factors are well correlated against the library sizes (Figure 5), indicating that capture 
# efficiency and sequencing depth are the major biases. 
plot(sce$total_counts, sizeFactors(sce), log="xy")
cor(sce$total_counts, sizeFactors(sce))

# Finally, we compute normalized log-expresion values. There is no need to call  computeSpikeFactors() 
# here, as there are no spike-in transcripts available.
sce <- normalize(sce) # log转换
sce # 增加了logcounts这个slot，默认是return_log=TRUE，所以返回的是logcounts；如果return_log=FALSE，增加的slot是normcounts
## 其实现步骤是根据size factor对测序文库的大小进行normalization，然后根据return_log参数决定是否需要log转换。
?normalize # 建议查看这个函数的帮助文档。

#################################### Modelling the mean-variance trend (根据表达均值和标准差来筛选基因) ####################################
# The lack of spike-in transcripts complicates the modelling of the technical noise. One option is to 
#assume that most genes do not exhibit strong biological variation, and to fit a trend to the 
# variances of endogenous genes. However, this assumption is generally unreasonable for a heterogeneous 
# population. Instead, we assume that the technical noise is Poisson and create a fitted trend on that 
# basis using the makeTechTrend() function. 
# 注意不同表达量的gene的techinical noise在这边定义为服从poisson分布
new.trend <- makeTechTrend(x=sce) # 计算technical noise，服从poisson分布，在下图以红色的点表示
str(new.trend)

# We estimate the variances for all genes and compare the trend fits in Figure 6. The Poisson-based 
# trend serves as a lower bound for the variances of the endogenous genes, consistent with non-zero 
# biological components.
# The blue line represents the mean-dependent trend fitted to the variances, while the red line 
# represents the Poisson noise.
fit <- trendVar(sce, use.spikes=FALSE, loess.args=list(span=0.05))
str(fit)
plot(fit$mean, fit$var, pch=16)   # 注意这里面每一个点都是一个gene
curve(fit$trend(x), col="dodgerblue", add=TRUE)
curve(new.trend(x), col="red", add=TRUE)
## The blue line represents the mean-dependent trend fitted to the variances, while the red line represents the Poisson noise.
## 红线是服从poisson分布的technical noise，蓝线是根据expression和variance的fit line。

# We decompose the variance for each gene using the Poisson-based trend, and examine the genes with 
# the highest biological components. 我们对每个gene的variance进行分解(分解为biological和technical variance)，基于poisson分布
fit0 <- fit
fit$trend <- new.trend
dec <- decomposeVar(fit=fit)   # Decompose the gene-specific variance into biological and technical components for single-cell RNA-seq data.
top.dec <- dec[order(dec$bio, decreasing=TRUE),]  
## bio的属性：Biological component of the variance；tech的属性：Technical component of the variance.
head(top.dec)


# We can plot the genes with the largest biological components, to verify that they are indeed highly 
# variable (Figure 7). Distributions of normalized log-expression values for the top 10 genes with the 
# largest biological components in the PBMC dataset. Each point represents the log-expression value in 
# a single cell.
plotExpression(sce, features=rownames(top.dec)[1:10])  # Each point represents the log-expression value in a single cell.


#################################### Dimensionality reduction 数据降维 ####################################
# We use the denoisePCA() function with the assumed Poisson technical trend, to choose the number of 
# dimensions to retain after PCA. The red line represents the chosen number of PCs.
# 首先采用PCA的线性降维，找到有意义的PC
sce <- denoisePCA(sce, technical=new.trend, approx=TRUE)
ncol(reducedDim(sce, "PCA"))

str(reducedDim(sce)) # 结果是两个大的slot，第一个slot是每个PC中每个gene的weight；第二个slot是每个PC对variance的贡献
attr(reducedDim(sce), "percentVar")  # 使用attr函数调取每个PC对variance的贡献
plot(attr(reducedDim(sce), "percentVar"), xlab="PC",   # 绘制碎石图
     ylab="Proportion of variance explained")
abline(v=ncol(reducedDim(sce, "PCA")), lty=2, col="red")  # The red line represents the chosen number of PCs.

# Examination of the first few PCs already reveals some strong substructure in the data (Figure 9).
# Pairwise PCA plots of the first three PCs in the PBMC dataset, constructed from normalized 
# log-expression values of genes with positive biological components.
# Each point represents a cell, coloured by the log-number of expressed features.
plotPCA(sce, ncomponents=3, colour_by="log10_total_features_by_counts")

# This is recapitulated with a t-SNE plot (Figure 10). Again, note that we set use_dimred= to perform 
# t-SNE on the denoised expression matrix. Each point represents a cell and is coloured according to 
# the log-number of expressed features. t-SNE是基于PCA筛选出来的有效PC的结果之上的，颜色根据log转换后的表达的feature。
sce <- runTSNE(sce, use_dimred="PCA", perplexity=30, rand_seed=100)
plotTSNE(sce, colour_by="log10_total_features_by_counts")

#################################### Clustering with graph-based methods 基于graph-based的聚类方法 ####################################
# We build a shared nearest neighbour graph (Xu and Su 2015) and use the Walktrap algorithm to 
# identify clusters.
# 我们进行可视化往往采用PCA+tSNE，但是clustering往往是PCA+其它方法，例如SNN
snn.gr <- buildSNNGraph(sce, use.dimred="PCA")
clusters <- igraph::cluster_walktrap(snn.gr)
sce$Cluster <- factor(clusters$membership)
table(sce$Cluster)

# We look at the ratio of the observed and expected edge weights to confirm that the clusters are 
# modular. (We don’t look at the modularity score itself, as that varies by orders of magnitudes 
# across clusters and is difficult to interpret.) Figure 11 indicates that most of the clusters 
# are well seperated, with few strong off-diagonal entries.
cluster.mod <- clusterModularity(snn.gr, sce$Cluster, get.values=TRUE)
log.ratio <- log2(cluster.mod$observed/cluster.mod$expected + 1)

library(pheatmap)
pheatmap(log.ratio, cluster_rows=FALSE, cluster_cols=FALSE, 
         color=colorRampPalette(c("white", "blue"))(100))
## Heatmap of the log10-ratio of the total weight between nodes in the same cluster or in different clusters, relative to 
## the total weight expected under a null model of random links

# We examine the cluster identities on a t-SNE plot (Figure 12) to confirm that different clusters 
# are indeed separated.
plotTSNE(sce, colour_by="Cluster")
## Each point represents a cell and is coloured according to its cluster identity.
## 赋予颜色，同时也能看出来，通过t-SNE的得到的二维展现的每个独立的群，是否和使用SNN算法计算得到的cluster相吻合。



######################################## Marker gene detection 寻找marker gene ######################################
# We detect marker genes for each cluster using findMarkers(). Again, we only look at upregulated 
# genes in each cluster, as these are more useful for positive identification of cell types in a 
# heterogeneous population. 只focus在高表达的gene
markers <- findMarkers(sce, clusters=sce$Cluster, direction="up")
str(markers) # 这里一共13个cluster，计算每个cluster的marker gene，并给出与任意一个其它cluster的logFC的数值。
# We examine the markers for cluster 1 in more detail. The upregulation of genes such as PF4 and 
# PPBP suggests that cluster 1 contains platelets or their precursors.
marker.set <- markers[["1"]]
head(marker.set[,1:8], 10) # only first 8 columns, for brevity

# This is confirmed in Figure 13, where the transcriptional profile of cluster 1 is clearly distinct 
# from the others.
chosen <- rownames(marker.set)[marker.set$Top <= 10] # 我们选择了在cluster1中高表达的前10个gene
plotHeatmap(sce, features=chosen, exprs_values="logcounts", 
            zlim=5, center=TRUE, symmetric=TRUE, cluster_cols=FALSE,
            colour_columns_by="Cluster", columns=order(sce$Cluster))
## Heatmap of mean-centred and normalized log-expression values for the top set of markers for cluster 1 in the PBMC dataset
## Column colours represent the cluster to which each cell is assigned, as indicated by the legend.

######################################## Concluding remarks ########################################
saveRDS(sce, file="pbmc_data.rds")


#==============================================================================================
#
#                    1.Analyzing single-cell RNA-seq data containing UMI counts
#
#==============================================================================================

# This workflow will adapt many of the previous concepts to analysis of UMI count data, using a large dataset of 
# 3005 cells from the mouse brain (Zeisel et al. 2015) generated from the Fluidigm system (Pollen et al. 2014). 
# It will focus on the modifications required to handle lower UMI counts and larger numbers of cells.

## updated in 2018-05-25, R version: 3.5.0
setwd('/Users/mijiarui/Nature_Biotechnology_Paper/simpleSingleCell')
library(simpleSingleCell)

######################################### Overview 项目简介##########################################

## In this workflow, we examine a heterogeneous dataset from a study of cell types in the mouse 
## brain (Zeisel et al. 2015). This contains approximately 3000 cells of varying types such as 
## oligodendrocytes, microglia and neurons. Individual cells were isolated using the Fluidigm C1 
## microfluidics system (Pollen et al. 2014) and library preparation was performed on each cell 
## using a UMI-based protocol. After sequencing, expression was quantified by counting the number 
## of UMIs mapped to each gene.
## # 使用的Fluidigm C1进行细胞分选，UMI对转录本进行计数，加入spike-in

#################################### Setting up the data 构建数据对象 ####################################
# 在这里作者定义了一个数据合并函数，将存储在不同文件中的内源基因，spike-in和线粒体基因的文件加以合并
# 注意这个函数的定义只使用于当前数据集，如果需要改动，建议首先查看自己的数据集。因为数据文件比较大，
# 建议在终端使用less命令打开。
readFormat <- function(infile) { 
  # First column is empty.
  metadata <- read.delim(infile, stringsAsFactors=FALSE, header=FALSE, nrow=10)[,-1] 
  rownames(metadata) <- metadata[,1]
  metadata <- metadata[,-1]
  metadata <- as.data.frame(t(metadata))
  
  # First column after row names is some useless filler.
  counts <- read.delim(infile, stringsAsFactors=FALSE, 
                       header=FALSE, row.names=1, skip=11)[,-1] 
  counts <- as.matrix(counts)
  return(list(metadata=metadata, counts=counts))
}
## 要理解上述代码，一定要先看一下文件的格式，先了解你的数据；为了避免读入数据过大，我们加载线粒体基因看一下
## 可以使用Linux的ls函数查看。我们发现前10行为metadata的内容，11行是一个空行，之后是表达矩阵

## Load in data, read in counts for the endogenous genes, ERCC spike-in transcripts and mitochondrial genes
## 每次读入的结果都是一个list
endo.data <- readFormat("expression_mRNA_17-Aug-2014.txt")
spike.data <- readFormat("expression_spikes_17-Aug-2014.txt")
mito.data <- readFormat("expression_mito_17-Aug-2014.txt")
str(endo.data)
endo.data$counts[1:6,1:6]

## We also need to rearrange the columns for the mitochondrial data, as the order is not consistent with the 
## other files. 对线粒体基因的细胞重新进行排序，以求一致，我们看到顺序是不一致的。
head(endo.data$metadata$cell_id)
head(mito.data$metadata$cell_id)
m <- match(endo.data$metadata$cell_id, mito.data$metadata$cell_id)
mito.data$metadata <- mito.data$metadata[m,]
mito.data$counts <- mito.data$counts[,m]

## In this particular dataset, some genes are represented by multiple rows corresponding to alternative genomic 
## locations. We sum the counts for all rows corresponding to a single gene for ease of interpretation.
## 有些gene在基因组中会多次出现（不同的位置），需要对他们的计数结果进行合并；在这个例子中，这种类型的gene的名字会有"_loc1"
## 这样的标注
### 字符串的替换
raw.names <- sub("_loc[0-9]+$", "", rownames(endo.data$counts))  # 首先我们把这些gene找到，并对结果进行替换
?rowsum # 对同一个分类变量进行纵向求和，Compute column sums across rows of a numeric matrix-like object for each level of a grouping variable.
new.counts <- rowsum(endo.data$counts, group=raw.names, reorder=FALSE)
endo.data$counts <- new.counts

## The counts are then combined into a single matrix for constructing a  SingleCellExperiment object. For 
## convenience, metadata for all cells are stored in the same object for later access.
## 开始构建SingleCellExperiment对象
library(SingleCellExperiment)
all.counts <- rbind(endo.data$counts, mito.data$counts, spike.data$counts) # 数据的纵向合并
sce <- SingleCellExperiment(list(counts=all.counts), colData=endo.data$metadata)
dim(sce)
sce

## We add gene-based annotation identifying rows that correspond to each class of features. We also determine the Ensembl identifier for each row.
## Specifying the nature of each row.
nrows <- c(nrow(endo.data$counts), nrow(mito.data$counts), nrow(spike.data$counts))
nrows
is.spike <- rep(c(FALSE, FALSE, TRUE), nrows); length(is.spike) # 注意向量化操作，内源重复19805次，mito重复34次，spike-in重复57次
is.mito <- rep(c(FALSE, TRUE, FALSE), nrows); length(is.mito)
isSpike(sce, "Spike") <- is.spike

## Adding Ensembl IDs.
library(org.Mm.eg.db)
ensembl <- mapIds(org.Mm.eg.db, keys=rownames(sce), keytype="SYMBOL", column="ENSEMBL")
rowData(sce)$ENSEMBL <- ensembl
sce 



#################################### Quality control on the cells 对细胞进行质控 ####################################

# The original authors of the study have already removed low-quality cells prior to data publication. 
# Nonetheless, we compute some quality control metrics with scater (McCarthy et al. 2017) to check whether the 
# remaining cells are satisfactory.
library(scater)
sce <- calculateQCMetrics(sce, feature_controls=list(Mt=is.mito)) 
sce # 查看sce，发现最大的区别在于colData从原来的10列变成现在的65列


## We examine the distribution of the QC metrics across all cells (Figure 1). The library sizes here are at 
## least one order of magnitude lower than observed in the 416B dataset. This is consistent with the use of UMI 
## counts rather than read counts, as each transcript molecule can only produce one UMI count but can yield many 
## reads after fragmentation. In addition, the spike-in proportions are more variable than observed in the 416B 
## dataset. This may reflect a greater variability in the total amount of endogenous RNA per cell when many cell 
## types are present.
## 作者在这里对数据的结果进行了解释。首先数据量比下面采用reads counts的结果要少一个数量级，这是因为使用UMI的策略，每个转录本
## 只产生一个UMI，然而可以产生多个reads（经过reads打断以后）。另外spike-in的比例的变异度较大，这也提示了细胞内原有的RNA
## 数量的变异度很大。这是可以理解的，因为神经细胞当中的细胞种类数目很多。
names(colData(sce))
par(mfrow=c(2,2), mar=c(5.1, 4.1, 0.1, 0.1))
hist(sce$total_counts/1e3, xlab="Library sizes (thousands)", main="",  # 使用$符号可以从SingleCellExperiment里面提取所有colData的信息，相当于对细胞进行质控
     breaks=20, col="grey80", ylab="Number of cells")
hist(sce$total_features, xlab="Number of expressed genes", main="", 
     breaks=20, col="grey80", ylab="Number of cells")
hist(sce$pct_counts_Spike, xlab="ERCC proportion (%)",
     ylab="Number of cells", breaks=20, main="", col="grey80")
hist(sce$pct_counts_Mt, xlab="Mitochondrial proportion (%)", 
     ylab="Number of cells", breaks=20, main="", col="grey80")
### Histograms of QC metrics including the library sizes, number of expressed genes and proportion of UMIs assigned to spike-in 
### transcripts or mitochondrial genes for all cells in the brain dataset


## We remove small outliers for the library size and the number of expressed features, and large outliers for 
## the spike-in proportions. Again, the presence of spike-in transcripts means that we do not have to use the 
## mitochondrial proportions. 有spike-in的存在，线粒体基因的比例就不是很重要了。
## 这边nmads的参数含义是“A numeric scalar, specifying the minimum number of MADs away from median required for 
## a value to be called an outlier.” MAD的意思是中位绝对偏差；我们滤除reads counts数，检测的gene数偏少，和那些
## spike-in比例偏高的细胞。
## 以下每一个结果，包括上面以is开头的函数，返回的都是每个细胞针对该筛选条件得到的True or False的结论。
libsize.drop <- isOutlier(sce$total_counts, nmads=3, type="lower", log=TRUE)
feature.drop <- isOutlier(sce$total_features, nmads=3, type="lower", log=TRUE)
spike.drop <- isOutlier(sce$pct_counts_Spike, nmads=3, type="higher")


## Removal of low-quality cells is then performed by combining the filters for all of the metrics. The majority 
## of cells are retained, which suggests that the original quality control procedures were generally adequate.
sce
sce <- sce[,!(libsize.drop | feature.drop | spike.drop)]
sce  # 从原来3005个细胞过滤后，变为2987个细胞
data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop), 
           BySpike=sum(spike.drop), Remaining=ncol(sce))
### We could improve our cell filtering procedure further by setting batch in isOutlier to one or more known 
### factors, e.g., mouse/plate of origin. As previously mentioned, this would avoid inflation of the MAD and 
### improve power to remove low-quality cells. However, for simplicity, we will not do this as sufficient 
### quality control has already been performed.

#################################### Cell cycle classifications 细胞周期的鉴定 ####################################
# 使用scran包中的cyclone函数对细胞周期进行判断，当然我们需要家在Ensembl的identifiers来match up预先定义的classifier
library(scran)
mm.pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", package="scran")) # 目前有人和小鼠的数据，暂无zebrafish的数据
assignments <- cyclone(sce, mm.pairs, gene.names=rowData(sce)$ENSEMBL) # 这一步很耗时
table(assignments$phase) # 返回统计结果，scran包中的cyclone函数目前只能返回3个周期的结果
par(mfrow = c(1,1), mar = c(5,5,3,2))
plot(assignments$score$G1, assignments$score$G2M, xlab="G1 score", ylab="G2/M score", pch=16)

# 得到每个细胞的各种周期的得分，那么就可以制作热图啦：
head(assignments$scores)
pheatmap::pheatmap(t(assignments$scores))

## However, the intepretation of this result requires some caution due to differences between the training and test datasets. 
## The classifier was trained on C1 SMARTer data and accounts for the biases in that protocol. The brain dataset uses UMI 
## counts, which has a different set of biases, e.g., 3’-end coverage only, no length bias, no amplification noise. Furthermore, 
## many neuronal cell types are expected to lie in the G0 resting phase, which is distinct from the other phases of the cell 
## cycle (Coller, Sang, and Roberts 2006). cyclone will generally assign such cells to the closest known phase in the training 
## set, which would be G1.


#################################### Examining gene-level metrics 探索表达数据 ####################################
# Figure 3 shows the most highly expressed genes across the cell population in the brain dataset. This is 
# mostly occupied by spike-in transcripts, reflecting the use of spike-in concentrations that span the entire 
# range of expression. There are also a number of constitutively expressed genes, as expected.
# 正如我们预期的，spike-in数据和管家基因的表达最高
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
plotQC(sce, type = "highest-expression", n=50) + fontsize # 这步非常耗时，导出图片也非常耗时

# Gene abundance is quantified by computing the average count across all cells (Figure 4). As previously 
# mentioned, the UMI count is generally lower than the read count. 根据细胞内表达的基因的average count数量绘制直方图
ave.counts <- calcAverage(sce, use_size_factors=FALSE)
hist(log10(ave.counts), breaks=100, main="Histogram of log-average counts for all genes in the brain dataset", 
     col="grey", xlab=expression(Log[10]~"average count"))
## Histogram of log-average counts for all genes in the brain dataset

# We save the average counts into the SingleCellExperiment object for later use. We also remove genes that have 
# average counts of zero, as this means that they are not expressed in any cell.
rowData(sce)$ave.count <- ave.counts
to.keep <- ave.counts > 0
sce <- sce[to.keep,]
summary(to.keep)


############################## Normalization of cell-specific biases 去除细胞特异的混杂因素 ##############################
# For endogenous genes, normalization is performed using the computeSumFactors function as previously described. 
# Here, we cluster similar cells together and normalize the cells in each cluster using the deconvolution method 
# (Lun, Bach, and Marioni 2016). This improves normalization accuracy by reducing the number of DE genes between 
# cells in the same cluster. Scaling is then performed to ensure that size factors of cells in different clusters 
# are comparable.

# We use a average count threshold of 0.1 to define high-abundance genes to use during normalization. 
# This is lower than the default threshold of min.mean=1 in  computeSumFactors, reflecting the fact that UMI 
# counts are generally smaller than read counts.
# 首先进行quickCluster，将类似的细胞归类为一个cluster，然后使用deconvolution方法对每一个cluster进行归一化
# 这一步有助于减少在同一个cluster中差异基因的数量
clusters <- quickCluster(sce, min.mean=0.1, method="igraph") 
## 注意这边因为是UMI，所以我们将high-abundance genes的阈值降到0.1
## quickCluster uses distances based on Spearman’s rank correlation for clustering. This ensures that scaling 
## biases in the counts do not affect clustering, but yields very coarse clusters and is not recommended for 
## biological interpretation. quickCluster采用的是Spearman秩和相关性，这样规避了counts数对cluster的影响，但是
## 其产生的结果是一个非常粗略的结果，不建议对其进行生物学的解释。
## For large datasets, using method="igraph" in quickCluster will speed up clustering. This uses a graph-based 
## clustering algorithm - see ?buildSNNGraph for more details. 'igraph'意味着使用了graph-based clustering算法

# 对于内源基因，我们还是采用computeSumFactors的方法。
sce <- computeSumFactors(sce, cluster=clusters, min.mean=0.1)
## Only a rough clustering is required to avoid pooling together very different cell types in  computeSumFactors. 
## The function is robust to a moderate level of differential expression between cells in the same cluster.

summary(sizeFactors(sce))


# Compared to the 416B analysis, more scatter is observed around the trend between the total count and size 
# factor for each cell (Figure 5). This is consistent with an increased amount of DE between cells of different 
# types, which compromises the accuracy of library size normalization (Robinson and Oshlack 2010). In contrast, 
# the size factors are estimated based on median ratios and are more robust to the presence of DE between cells.
plot(sizeFactors(sce), sce$total_counts/1e3, log="xy",
     ylab="Library size (thousands)", xlab="Size factor")
## Size factors from deconvolution, plotted against library sizes for all cells in the brain dataset. axis on a log-scale

# We also compute size factors specific to the spike-in set, as previously described.
sce <- computeSpikeFactors(sce, type="Spike", general.use=FALSE)

# Finally, normalized log-expression values are computed for each endogenous gene or spike-in transcript using 
# the appropriate size factors.
sce  # assay目前只有counts这一个slot
sce <- normalize(sce) # assays增加了logcounts这个slot


############################## Modelling and removing technical noise 去除technical noise并寻找HVGs ##############################
# 说白了，这一步就是分解出biological variance，然后找到HVGs
# We model the technical noise by fitting a mean-variance trend to the spike-in transcripts
# 根据spike-in的variance去除表达的technical noise
# In theory, we should block on the plate of origin for each cell. However, only 20-40 cells are available on each 
# plate, and the population is also highly heterogeneous. This means that we cannot assume that the distribution of 
# sampled cell types on each plate is the same. Thus, to avoid regressing out potential biology, we will not block 
# on any factors in this analysis.
var.fit <- trendVar(sce, parametric=TRUE, loess.args=list(span=0.4))
var.out <- decomposeVar(sce, var.fit)
?decomposeVar   # 分解variance

# Figure 6 indicates that the trend is fitted accurately to the technical variances. The technical and total variances 
# are also much smaller than those in the 416B dataset. This is due to the use of UMIs, which reduces the noise caused 
# by variable PCR amplification (Islam et al. 2014). Furthermore, the spike-in trend is consistently lower than the 
# variances of the endogenous genes. This reflects the heterogeneity in gene expression across cells of different types.
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
     ylab="Variance of log-expression")
points(var.out$mean[isSpike(sce)], var.out$total[isSpike(sce)], col="red", pch=16)
curve(var.fit$trend(x), col="dodgerblue", add=TRUE, lwd=2)
## Variance of normalized log-expression values against the mean for each gene, calculated across all cells in the brain 
## dataset after blocking on the sex effect
## The blue line represents the mean-dependent trend in the technical variance of the spike-in transcripts (also 
## highlighted as red points).

# We check the distribution of expression values for the genes with the largest biological components to ensure that 
# they are not driven by outliers (Figure 7). Some tweaking of the  plotExpression parameters is necessary to visualize 
# a large number of cells. 我们查看一下这些变异度最大的基因，并且观察一下它们非常大的变异度是否来自于离群值
# 说白了，这一步就是分解出biological variance，然后找到HVGs
chosen.genes <- order(var.out$bio, decreasing=TRUE)[1:10]    # bio的意思是这个变异是来自于biology而非technical
plotExpression(sce, rownames(var.out)[chosen.genes], 
               alpha=0.05, jitter="jitter") + fontsize  # 对plotExpression函数内的参数进行微调以容纳更多的点
## Violin plots of normalized log-expression values for the top 10 HVGs in the brain dataset
## For each gene, each point represents the log-expression value for an individual cell.


# PCA分析进行数据降维去除噪声，找到真正有意义的PC
# Finally, we use PCA to denoise the expression values, yielding a set of coordinates for each cell where the technical 
# noise has been removed. Setting approximate=TRUE in denoisePCA will perform an approximate singular value decomposition, 
# using methods from the irlba package. This is much faster than the exact algorithm on large datasets without much loss 
# of accuracy.
sce <- denoisePCA(sce, technical=var.fit$trend, approximate=TRUE)
ncol(reducedDim(sce, "PCA"))
sce # 增加了reducedDimNames

########################## Data exploration with dimensionality reduction 数据降维 ##########################
# We perform dimensionality reduction on the denoised PCs to check if there is any substructure. 
# Cells separate into clear clusters in the t-SNE plot (Van der Maaten and Hinton 2008) in Figure 8, 
# corresponding to distinct subpopulations. This is consistent with the presence of multiple cell types in the 
# diverse brain population. We increase the perplexity to favour visualization of the overall structure at the 
# expense of local scale.
# 在PCA的基础上进一步数据降维可视化，使用t-SNE。我们可以比较不同perplexity的情况，perplexity越大，越能反映数据的
# 整体结构，但是会牺牲一部分局部scale。
sce <- runTSNE(sce, use_dimred="PCA", perplexity=20, rand_seed=1000) # 绘图点之间会比较疏远/稀疏
sce <- runTSNE(sce, use_dimred="PCA", perplexity=50, rand_seed=1000) # 同一个cluster的点会比较紧密
tsne1 <- plotTSNE(sce, colour_by="Neurod6") + fontsize
tsne2 <- plotTSNE(sce, colour_by="Mog") + fontsize
multiplot(tsne1, tsne2, cols=2)
## t-SNE plots constructed from the denoised PCs of the brain dataset
## Each point represents a cell and is coloured according to its expression of Neurod6 (left) or Mog (right).


# The PCA plot is less effective at separating cells into many different clusters (Figure 9). 
# This is because the first two PCs are driven by strong differences between specific subpopulations, 
# which reduces the resolution of more subtle differences between some of the other subpopulations. 
# Nonetheless, some substructure is still visible.
# PCA在进行区分的时候会less effective，这是因为前两个PC主要是由几个差异比较大的subpopulation(的gene)来贡献的
# 因此在区分差异比较小的subpopulation的时候，分辨率就会非常低。
pca1 <- plotReducedDim(sce, use_dimred="PCA", colour_by="Neurod6") + fontsize
pca2 <- plotReducedDim(sce, use_dimred="PCA", colour_by="Mog") + fontsize
multiplot(pca1, pca2, cols=2)
## PCA plots constructed from the denoised PCs of the brain dataset
## Each point represents a cell and is coloured according to its expression of the Neurod6 (left) or Mog (right).

## For both methods, we colour each cell based on the expression of a particular gene. This is a 
## useful strategy for visualizing changes in expression across the lower-dimensional space. 
## It can also be used to characterise each cluster if the selected genes are known markers for 
## particular cell types. For example, Mog can be used to identify clusters corresponding to 
## oligodendrocytes.

########################## Clustering cells into putative subpopulations 对细胞进行clustering ##########################
# The reduced dimension coordinates are used to cluster cells into putative subpopulations. 
# We do so by constructing a shared-nearest-neighbour graph (Xu and Su 2015), in which cells 
# are the nodes and edges are formed between cells that share nearest neighbours. Clusters are 
# then defined as highly connected communities of cells within this graph, using methods from 
# the igraph package. This is more efficient than forming a pairwise distance matrix for 
# hierarchical clustering of large numbers of cells.
# 共享最近邻聚类算法: Decreasing the number of neighbours k in buildSNNGraph will reduce the 
# connectivity of the graph. This will generally result in the formation of smaller clusters 
# (Xu and Su 2015), which may be desirable if greater resolution is required.
# scater包提倡在进行聚类的时候（给每个细胞赋予一个cluster），采用share-nearest-neighbour graph方法
# 在这个方法中，细胞是node，而edge则是共享最近邻近聚类的细胞的关系。所以最后cluster的产生是被定义
# 为图中高度连结的一群点/细胞。这个方法比传统的计算点与点之间的pairwise distance矩阵，然后得到的层次
# 聚类结果会更加高效。在igraph包中整合了很多基于graph-based的clustering方法，其中walktrap算法作为
# 一个默认算法，是非常推荐使用的。
snn.gr <- buildSNNGraph(sce, use.dimred="PCA")  # 注意k的默认值为10，关于k的解释看下方注释
?buildSNNGraph
cluster.out <- igraph::cluster_walktrap(snn.gr)   # 使用了walktrap算法。
my.clusters <- cluster.out$membership
table(my.clusters)  # 与tutorial有的结果稍有不同
## Decreasing the number of neighbours k in buildSNNGraph will reduce the connectivity of the graph. This will 
## generally result in the formation of smaller clusters (Xu and Su 2015), which may be desirable if greater 
## resolution is required.

# The modularity score provides a global measure of clustering performance for community 
# detection methods. Briefly, it compares the number of within-cluster edges to the expected 
# number under a null model of random edges. A high modularity score (approaching the maximum of 
# 1) indicates that the detected clusters are enriched for internal edges, with relatively few 
# edges between clusters.

# Notice that we do not run library(igraph), but instead use igraph:: to extract methods from 
# the package. This is because igraph contains a normalize method that will override its 
# counterpart from scater, resulting in some unusual bugs.
igraph::modularity(cluster.out)   # 这个值越大(越接近1)则说明聚类的结果越优异。


# We further investigate the clusters by examining the total weight of edges for each pair of 
# clusters. For each pair, the observed total weight is compared to what is expected under a 
# null model, similar to the modularity calculation. Most clusters contain more internal links 
# than expected (Figure 10), while links between clusters are fewer than expected. This indicates 
# that we successfully clustered cells into highly-connected communities.
# 这张图也是来评估cluster分的好不好，理论上一个cluster的细胞，edge会越高，而不同cluster的细胞之间
# 的edge会越低。
mod.out <- clusterModularity(snn.gr, my.clusters, get.values=TRUE)
ratio <- log10(mod.out$observed/mod.out$expected + 1)
library(pheatmap)
pheatmap(ratio, cluster_rows=FALSE, cluster_cols=FALSE, 
         color=colorRampPalette(c("white", "blue"))(100))
## Heatmap of the log10-ratio of the total weight (edge) between nodes in the same cluster or in different clusters, 
## relative to the total weight expected under a null model of random links

# We visualize the cluster assignments for all cells on the t-SNE plot in Figure 11. Adjacent 
# cells are generally assigned to the same cluster, indicating that the clustering procedure was 
# applied correctly.
sce$cluster <- factor(my.clusters)
plotTSNE(sce, colour_by="cluster") + fontsize
## t-SNE plot of the denoised PCs of the brain dataset
## Each point represents a cell and is coloured according to its assigned cluster identity.

# An alternative approach is to use graph-based visualizations such as force-directed layouts 
# (Figure 12). These are appealing as they directly represent the relationships used during 
# clustering. However, convergence tends to be slow for large graphs, so some tinkering with 
# niter= may be required to ensure that the results are stable.
# 在数据呈现上，出了t-SNE以外，我们也可以干脆使用graph-based visualization，比如force-directed layouts
# 它的好处是直接可以图形化反应clustering算法的结果，但是convergence非常缓慢，需要我们添加参数让结果
# 更加稳健。
set.seed(2000)
reducedDim(sce, "force") <- igraph::layout_with_fr(snn.gr, niter=5000)
plotReducedDim(sce, colour_by="cluster", use_dimred="force")
## Force-directed layout for the shared nearest-neighbour graph of the brain dataset
## Each point represents a cell and is coloured according to its assigned cluster identity.

## 对于一些比较大的数据集，我们上述的步骤分出来的群可能也只是第一次粗分，后续需要subset某个群进一步细分。
## Very heterogeneous datasets may yield a few large clusters on the first round of clustering. It can be useful to 
## repeat the variance modelling, denoising and clustering using only the cells within each of the initial clusters. 
## This can be achieved by subsetting sce according to a particular level of my.clusters, and re-applying the relevant 
## functions on the subset. Doing so may focus on a different set of genes that define heterogeneity within an initial 
## cluster, as opposed to those that define differences between the initial clusters. This would allow fine-scale 
## structure within each cluster to be explored at greater resolution. For simplicity, though, we will only use the broad 
## clusters corresponding to clear subpopulations in this workflow.


########################## Detecting marker genes between subpopulations 寻找不同subpopulation的marker gene ##########################
# We use the findMarkers function with direction="up" to identify upregulated marker genes for 
# each cluster. As previously mentioned, we focus on upregulated genes as these can quickly 
# provide positive identification of cell type in a heterogeneous population. We examine the 
# table for cluster 1, in which log-fold changes are reported between cluster 1 and every other 
# cluster. The same output is provided for each cluster in order to identify genes that 
# discriminate between clusters.
# 我们使用findMarkers函数并且定义参数direction = "up" 来鉴定上调的marker genes
markers <- findMarkers(sce, my.clusters, direction="up")
marker.set <- markers[["1"]]
head(marker.set[,1:8], 10) # only first 8 columns, for brevity
?overlapExprs
groups <- sample(3, ncol(sce), replace=TRUE)
out <- overlapExprs(sce, groups, subset.row=1:10)
out
## 我们也可以使用overlapExprs函数来总结每个cluster的差异
## The overlapExprs function may also be useful here, to prioritize candidates where there is clear separation 
## between the distributions of expression values of different clusters. This differs from findMarkers, which is 
## primarily concerned with the log-fold changes in average expression between clusters.

# We save the list of candidate marker genes for further examination, using compression to 
# reduce the file size.
gzout <- gzfile("brain_marker_1.tsv.gz", open="wb")
write.table(marker.set, file=gzout, sep="\t", quote=FALSE, row.names=FALSE)
close(gzout)

# Figure 13 indicates that most of the top markers are strongly DE in cells of cluster 1 compared 
# to some or all of the other clusters. We can use these markers to identify cells from cluster 1
# in validation studies with an independent population of cells. A quick look at the markers suggest 
# that cluster 1 represents interneurons based on expression of Gad1 and Slc6a1 (Zeng et al. 2012), 
# differing from closely related cells in cluster 10 by virtue of high Synpr expression.
top.markers <- rownames(marker.set)[marker.set$Top <= 10]
plotHeatmap(sce, features=top.markers, columns=order(my.clusters),
            colour_columns_by="cluster", cluster_cols=FALSE, 
            center=TRUE, symmetric=TRUE, zlim=c(-5, 5))
## Heatmap of mean-centred and normalized log-expression values for the top set of markers for cluster 1 in the 
## brain dataset
## Column colours represent the cluster to which each cell is assigned, as indicated by the legend.

################################## Concluding remarks ##################################
# Having completed the basic analysis, we save the SingleCellExperiment object with its associated 
# data to file. This is especially important here as the brain dataset is quite large. If further 
# analyses are to be performed, it would be inconvenient to have to repeat all of the pre-processing 
# steps described above.
saveRDS(file="brain_data.rds", sce)


#==============================================================================================
#
#             2. Analyzing single-cell RNA-seq data containing read counts (SMART-seq2)
#
#==============================================================================================

# This workflow will introduce most of the concepts for scRNA-seq data analysis, using a small dataset of 192 cells 
# from an immortalized myeloid progenitor cell line (Lun et al. 2017) generated using the Smart-seq2 protocol 
# (Picelli et al. 2014). It will start from loading of the data and finish at the characterization of cell clusters.

############################################ Overview 项目简介 ############################################

# In this workflow, we use a relatively simple dataset (Lun et al. 2017) to introduce most of the 
# concepts of scRNA-seq data analysis. This dataset contains two plates of 416B cells (an immortalized 
# mouse myeloid progenitor cell line), processed using the Smart-seq2 protocol (Picelli et al. 2014). 
# A constant amount of spike-in RNA from the External RNA Controls Consortium (ERCC) was also added to 
# each cell’s lysate prior to library preparation. High-throughput sequencing was performed and the 
# expression of each gene was quantified by counting the total number of reads mapped to its exonic 
# regions. Similarly, the quantity of each spike-in transcript was measured by counting the number of 
# reads mapped to the spike-in reference sequences. 
# SMART-seq2建库方案，ERCC spike-in (mapping to spike-in reference sequence)，count reads mapping to 
# exonic region

# 注意，在上游数据处理的时候：
# Some feature-counting tools will report mapping statistics in the count matrix (e.g., the number of 
# unaligned or unassigned reads). While these values can be useful for quality control, they would be 
# misleading if treated as gene expression values. Thus, they should be removed (or at least moved to 
# the colData) prior to further analyses.


##################################### Setting up the data 构建数据对象 #####################################

#----------------------# Load in count matrix 读取数据（密集矩阵） #----------------------#
# 建议先在终端查看一下matrix，通过观察这个tsv格式的文件，发现是常规的表达矩阵数据，密集矩阵的形式
# One matrix was generated for each plate of cells used in the study.
# unzip("E-MTAB-5522.processed.1.zip"). Unzip once. 这里我们关注标明“Calero”的数据集
# Reading in the count tables for each of the two plates.
setwd('/Users/mijiarui/Nature_Biotechnology_Paper/simpleSingleCell')
plate1 <- read.delim("counts_Calero_20160113.tsv", 
                     header=TRUE, row.names=1, check.names=FALSE)
plate2 <- read.delim("counts_Calero_20160325.tsv", 
                     header=TRUE, row.names=1, check.names=FALSE)
head(plate1[1:5,1:5])
gene.lengths <- plate1$Length # First column is the gene length.
plate1 <- as.matrix(plate1[,-1]) # Discarding gene length (as it is not a cell).
plate2 <- as.matrix(plate2[,-1])
rbind(Plate1=dim(plate1), Plate2=dim(plate2)) # 两个文件中均有96个细胞，检测46703个基因

# We combine the two matrices into a single object for further processing. This is done after 
# verifying that the genes are in the same order between the two matrices.
# 在对两个数据进行合并的时候(横向合并)，必须事先确认gene名是不是个数和顺序是一样的
stopifnot(identical(rownames(plate1), rownames(plate2)))
all.counts <- cbind(plate1, plate2)

# For convenience, the count matrix is stored in a SingleCellExperiment object from the SingleCellExperiment 
# package. This allows different types of row- and column-level metadata to be stored alongside the 
# counts for synchronized manipulation throughout the workflow.
library(SingleCellExperiment)
sce <- SingleCellExperiment(list(counts=all.counts)) # 构建SingleCellExperiment对象的时候最少只需要输入矩阵信息
sce   # rownames和colnames自动载入了；但是rowData和colData都为空
rowData(sce)$GeneLength <- gene.lengths
sce # assays中只有一个slot，是'counts'

# We identify the rows corresponding to ERCC spike-in transcripts from the row names. We store this 
# information in the SingleCellExperiment object for future use. This is necessary as spike-ins 
# require special treatment in downstream steps such as normalization.
# 一个很小的注意事项，在使用正则表达式去除ERCC spike-in的时候：
# Be aware of using the ^ERCC regular expression for human data where the row names of the count 
# matrix are gene symbols. An ERCC gene family actually exists in human annotation, so this would 
# result in incorrect identification of genes as spike-in transcripts. This problem can be avoided by 
# publishing count matrices with standard identifiers (e.g., Ensembl, Entrez).
# 这边需要注意的是基因名是ensembl id，因为ERCC与人的gene symbol在正则表达式中会有一些重合，所以处理的时候
# 一定要小心，建议看一下选出来的ERCC到底有哪些，以避免把内源基因给排除了。
isSpike(sce, "ERCC") <- grepl("^ERCC", rownames(sce)) # isSpike是sce这个SingleCellExperiment对象中的一个单元
row.names(sce)[grepl("^ERCC", rownames(sce))] # 可以用这句代码来查看具体每个ERCC的标签
summary(isSpike(sce, "ERCC")) # 或者用table函数也可以

# This dataset is slightly unusual in that it contains information from another set of spike-in 
# transcripts, the Spike-In RNA Variants (SIRV) set. For simplicity, we will only use the ERCC 
# spike-ins in this analysis. Thus, we must remove the rows corresponding to the SIRV transcripts 
# prior to further analysis, which can be done simply by subsetting the  SingleCellExperiment object.
# 这个数据集有两套spike-in，一套是ERCC spike-in，另一套是SIRV spike-in。我们剔除SIRV spike-in
is.sirv <- grepl("^SIRV", rownames(sce))
rownames(sce)[is.sirv] # 可以用这句代码来查看以‘SIRV’开头的另一套spike-in标签
sce <- sce[!is.sirv,] 
summary(is.sirv)
sce # SIRV不是常规使用的spike-in


#----------------------# Incorporating cell-based annotation 追加细胞的注释信息 #----------------------#
# We load in the metadata for each library/cell from the sdrf.txt file. It is important to check that 
# the rows of the metadata table are in the same order as the columns of the count matrix. Otherwise, 
# incorrect metadata will be assigned to each cell. metadata的列名和matrix的行名必须完全一致，尤其是顺序。
metadata <- read.delim("E-MTAB-5522.sdrf.txt", check.names=FALSE, header=TRUE)
head(metadata) # 在这个文件中，metadata的行名存储在列名为“Source Name"(实际为第一列)
m <- match(colnames(sce), metadata[["Source Name"]]) # Enforcing identical order，检测是否匹配
?match   # match returns a vector of the positions of (first) matches of its first argument in its second.
stopifnot(all(!is.na(m))) # Checking that nothing's missing.
metadata <- metadata[m,]
head(colnames(metadata))
dim(metadata)  # 我们看到metadata中的信息（列数）非常多，注意目前只是存储在一个名为metadata的中间变量


# We only retain relevant metadata fields to avoid storing unnecessary information in the  colData 
# of the SingleCellExperiment object. In particular, we keep the plate of origin (i.e., block) and 
# phenotype of each cell. The second field is relevant as all of the cells contain a CBFB-MYH11 
# oncogene, but the expression of this oncogene is only induced in a subset of the cells.
colData(sce)$Plate <- factor(metadata[["Factor Value[block]"]])
pheno <- metadata[["Factor Value[phenotype]"]]
levels(pheno) <- c("induced", "control") # 根据因子型变量的首字母在字母表中的顺序
colData(sce)$Oncogene <- pheno
table(colData(sce)$Oncogene, colData(sce)$Plate)

#----------------------# Incorporating gene-based annotation 追加基因的注释信息 #----------------------#
# Feature-counting tools typically report genes in terms of standard identifiers from Ensembl or 
# Entrez. These identifiers are used as they are unambiguous and highly stable. However, they are 
# difficult to interpret compared to the gene symbols which are more commonly used in the literature. 
# Given the Ensembl identifiers, we obtain the corresponding gene symbols using annotation packages 
# like org.Mm.eg.db. 定量分析软件一般使用Ensembl或者Entrez基因id，但是为了方便阅读，需要转换成gene symbol
# 这一步转化工作可以使用注释包，例如：org.Mm.eg.db; 如果是斑马鱼的，则是org.Dr.eg.db
library(org.Mm.eg.db)
symb <- mapIds(org.Mm.eg.db, keys=rownames(sce), keytype="ENSEMBL", column="SYMBOL") # 类似于键值对的概念；
## 提示信息：有可能多个Ensembl id会对应同一个gene symbol或者有缺失值
rowData(sce)$ENSEMBL <- rownames(sce)
rowData(sce)$SYMBOL <- symb
head(rowData(sce))
table(is.na(rowData(sce)$SYMBOL))  # 有相当一部分Ensembl id不能对应到gene symbol，显示为NA


# It is often desirable to rename the row names of sce to the gene symbols, as these are easier to 
# interpret. However, this requires some work to account for missing and duplicate symbols. The code 
# below will replace missing symbols with the Ensembl identifier and concatenate duplicated symbols 
# with the (unique) Ensembl identifiers. 将missing symbol和duplicated symbol都替换成ensembl gene id
new.names <- rowData(sce)$SYMBOL
missing.name <- is.na(new.names)
new.names[missing.name] <- rowData(sce)$ENSEMBL[missing.name]
dup.name <- new.names %in% new.names[duplicated(new.names)]
new.names[dup.name] <- paste0(new.names, "_", rowData(sce)$ENSEMBL)[dup.name]
rownames(sce) <- new.names
head(rownames(sce))

# We also determine the chromosomal location for each gene using the TxDb.Mmusculus.UCSC.mm10.ensGene 
# package. This will be useful later as several quality control metrics will be computed from rows 
# corresponding to mitochondrial genes. 因为QC步骤涉及到线粒体基因，所以有必要添加染色体的信息
library(TxDb.Mmusculus.UCSC.mm10.ensGene)
location <- mapIds(TxDb.Mmusculus.UCSC.mm10.ensGene, keys=rowData(sce)$ENSEMBL, 
                   keytype="GENEID", column="CDSCHROM")
table(location) # 查看一下线粒体基因的染色体标签名
rowData(sce)$CHR <- location
summary(location=="chrM")


##################################### Quality control on the cells 针对细胞的QC #####################################
#----------------------# Defining the quality control metrics 构建QC matrix #----------------------#
# Cells with small library sizes are of low quality as the RNA has not been efficiently captured 
# (i.e., converted into cDNA and amplified) during library preparation.

# The number of expressed features in each cell is defined as the number of features with non-zero 
# counts for that cell. Any cell with very few expressed genes is likely to be of poor quality as the 
# diverse transcript population has not been successfully captured. 
# 测序文库特别小的细胞是低质量细胞；检测到的基因�数少的是低质量细胞

# The proportion of reads mapped to spike-in transcripts is calculated relative to the library size 
# for each cell. High proportions are indicative of poor-quality cells, where endogenous RNA has been 
# lost during processing (e.g., due to cell lysis or RNA degradation). The same amount of spike-in 
# RNA to each cell, so an enrichment in spike-in counts is symptomatic of loss of endogenous RNA. 
# spike-in所占的比例过高提示cell quality比较差

# In the absence of spike-in transcripts, the proportion of reads mapped to genes in the mitochondrial 
# genome can also be used. High proportions are indicative of poor-quality cells 
# (Islam et al. 2014; Ilicic et al. 2016), possibly because of loss of cytoplasmic RNA from perforated cells. 
# The reasoning is that mitochondria are larger than individual transcript molecules and less likely to escape 
# through tears in the cell membrane.
# 在没有spike-in的情况下，使用线粒体基因的转录本也可以用于cell quality control；过高比例的线粒体基因转录本
# 提示细胞破损。毕竟线粒体多了一个细胞膜（还是双层的）不容易破损，里面的线粒体RNA不容易丢失，而细胞质内的RNA
# 容易收到细胞破损的影响而丢失。

# For each cell, we calculate these quality control metrics using the calculateQCMetrics function 
# from the scater package (McCarthy et al. 2017). These are stored in the row- and column-wise 
# metadata of the SingleCellExperiment for future reference.
library(scater)
mito <- which(rowData(sce)$CHR=="chrM") # 给出线粒体基因转录本的行号
sce <- calculateQCMetrics(sce, feature_controls=list(Mt=mito))
head(colnames(colData(sce)), 10)

# The distributions of these metrics are shown in Figure 1, stratified by oncogene induction status 
# and plate of origin. The aim is to remove putative low-quality cells that have low library sizes, 
# low numbers of expressed features, and high spike-in (or mitochondrial) proportions.
# 新增了一列叫PlateOnco
sce$PlateOnco <- paste0(sce$Oncogene, ".", sce$Plate)
table(sce$PlateOnco) # 是一个分类变量
multiplot(                  # multiplot是ggplot2下的函数
  plotColData(sce, y="total_counts", x="PlateOnco"),
  plotColData(sce, y="total_features", x="PlateOnco"),
  plotColData(sce, y="pct_counts_ERCC", x="PlateOnco"),
  plotColData(sce, y="pct_counts_Mt", x="PlateOnco"),
  cols=2)
## Distributions of various QC metrics for all cells in the 416B dataset
## This includes the library sizes, number of expressed genes, and proportion of reads mapped to spike-in transcripts 
## or mitochondrial genes.

# Generally, they will be in rough agreement, i.e., cells with low total counts will also have low 
# numbers of expressed features and high ERCC/mitochondrial proportions. Clear discrepancies may 
# correspond to technical differences between batches of cells (see below) or genuine biological 
# differences in RNA content.
par(mfrow=c(1,3))
plot(sce$total_features, sce$total_counts/1e6, xlab="Number of expressed genes",
     ylab="Library size (millions)")
plot(sce$total_features, sce$pct_counts_ERCC, xlab="Number of expressed genes",
     ylab="ERCC proportion (%)")
plot(sce$total_features, sce$pct_counts_Mt, xlab="Number of expressed genes",
     ylab="Mitochondrial proportion (%)")
## Behaviour of each QC metric compared to the total number of expressed features
## Each point represents a cell in the 416B dataset.

#----------------------# Identifying outliers for each metric 找到并排除离群值 #----------------------#
# 有的时候阈值的设定非常的tricky，我们不妨就假设大部分的cell都是high quality的，那么在离群值范围的
# 细胞我们就认为是低质量的细胞，需要filter掉。Outliers are defined based on the median absolute 
# deviation (MADs) from the median value of each metric across all cells. We remove cells with 
# log-library sizes that are more than 3 MADs below the median log-library size. A log-transformation 
# improves resolution at small values, especially when the MAD of the raw values is comparable to or 
# greater than the median. We also remove cells where the log-transformed number of expressed genes 
# is 3 MADs below the median value. 我们使用的是中位绝对偏差，我们讲检测到的library size(counts)和gene
# 数在3个MADs以下的排除掉；在进行MAD之前，先对数据进行log转换，这对非常小的数值的分析有帮助(improve
# resolution at small value，尤其是MAD比median还要大的情况下)
# 分别对reads count和feature�数进行过滤。
libsize.drop <- isOutlier(sce$total_counts, nmads=3, type="lower",  # isOutlier()是scater包的内置函数
                          log=TRUE, batch=sce$PlateOnco)    # 自带了log=这个参数
feature.drop <- isOutlier(sce$total_features, nmads=3, type="lower", 
                          log=TRUE, batch=sce$PlateOnco)
## The batch= argument ensures that outliers are identified within each level of the specified plate/oncogene 
## factor. This allows isOutlier() to accommodate systematic differences in the QC metrics across plates 
## (Figure 1), which can arise due to technical differences in processing (e.g., differences in sequencing depth) 
## rather than any changes in quality. The same reasoning applies to the oncogene induction status, where induced 
## cells may have naturally fewer expressed genes for biological reasons. Failing to account for these systematic 
## differences would inflate the MAD estimate and compromise the removal of low-quality cells.


# 我们也要滤除spike-in比例过高的细胞，为了更加清楚的展示(因为发现离群值中的大值)，我们不对ERCC的percentage
# 进行log转换，在有ERCC spike-in的情况下，就没有必要用线粒体基因作为参照了。
spike.drop <- isOutlier(sce$pct_counts_ERCC, nmads=3, type="higher",
                        batch=sce$PlateOnco)

# Subsetting by column will retain only the high-quality cells that pass each filter described above. 
# We examine the number of cells removed by each filter as well as the total number of retained cells. 
# Removal of a substantial proportion of cells (> 10%) may be indicative of an overall issue with data 
# quality.
keep <- !(libsize.drop | feature.drop | spike.drop)
data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop),
           BySpike=sum(spike.drop), Remaining=sum(keep))

# We then subset the SingleCellExperiment object to retain only the putative high-quality cells. 
# We also save the original object to file for later use.
sce$PassQC <- keep
saveRDS(sce, file="416B_preQC.rds")
sce # before cell QC，192个细胞
sce <- sce[,keep]
dim(sce) # after cell QC，183个细胞
## 我们发现有些细胞可能在多个条件上都不满足

################################### Classification of cell cycle phase 细胞周期的鉴定 ###################################
# 英国 Sanger 研究院的 Teichmann 等人就开发了一款单细胞隐藏 可变模型 (single-cell latent variable model, 
# scLVM) 和 Cyclone 软件。Cyclone 软 件可以利用机器学习技术和统计学的方法， 将细胞周期信息与单细胞 RNA 
# 测序数据结合起来，来帮助我们判断哪些基因表达信号与细胞周期的哪个阶段有关。对于任何单细胞的 RNA 测序数
# 据，使用 Cyclone 软件就能够使其与每一个细胞在细胞周期中所处的阶段一一对应。两者的 scLVM 就采用了在整个
# 细胞周期中表达程度高度可变的基因作为研究对象，来明确基因表达 与细胞周期的关系。他们确定了某一种决定细
# 胞周期的因子，也发现了在细胞发育或分化的 整个细胞周期中，推动细胞转化的因子，而且 还发现了一些独特的亚
# 群 (subpopulations)。设计到训练集和测试集和支持向量机：We use the prediction method described by Scialdone et al. 
# (2015) to classify cells into cell cycle phases based on the gene expression data. Using a training dataset, 
# the sign of the difference in expression between two genes was computed for each pair of genes. Pairs with 
# changes in the sign across cell cycle phases were chosen as markers. Cells in a test dataset can then be 
# classified into the appropriate phase, based on whether the observed sign for each marker pair is consistent 
# with one phase or another.
# This approach is implemented in the cyclone function from the scran package. The package contains a 
# pre-trained set of marker pairs for mouse data, which we can load in the the readRDS function. We use the 
# Ensembl identifiers for each gene in our dataset to match up with the names in the pre-trained set of gene pairs.
set.seed(100)
library(scran)
mm.pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", # 加载训练集
                                package="scran"))
assignments <- cyclone(sce, mm.pairs, gene.names=rowData(sce)$ENSEMBL)  # 判断测试集细胞的细胞周期状态
assignments # 结果是一个列表，包含分类的属性(phases)，score和normalized score
# Each cell is assigned a score for each phase, with a higher score corresponding to a higher probability 
# that the cell is in that phase. We focus on the G1 and G2/M scores as these are the most informative 
# for classification. 
par(mfrow = c(1,1))
plot(assignments$score$G1, assignments$score$G2M, 
     xlab="G1 score", ylab="G2/M score", pch=16)

# Cells are classified as being in G1 phase if the G1 score is above 0.5 and greater than the G2/M 
# score; in G2/M phase if the G2/M score is above 0.5 and greater than the G1 score; and in S phase 
# if neither score is above 0.5. Here, the vast majority of cells are classified as being in G1 phase. 
# We save these assignments into the SingleCellExperiment object for later use.
# 任何一个细胞期的打分高于0.5，就认为细胞处在那个期。
sce$phases <- assignments$phases
table(sce$phases)

# 可视化的展示
pheatmap::pheatmap(t(assignments$scores))
pheatmap::pheatmap(t(assignments$normalized.scores))

## 有几个注意点：
## To remove confounding effects due to cell cycle phase, we can filter the cells to only retain those 
## in a particular phase (usually G1) for downstream analysis. Alternatively, if a non-negligible number 
## of cells are in other phases, we can use the assigned phase as a blocking factor. This protects against 
## cell cycle effects without discarding information, and will be discussed later in more detail.
## 校正细胞周期的影响。

## The classifier may not be accurate for data that are substantially different from those used in 
## the training set, e.g., due to the use of a different protocol. In such cases, users can construct 
## a custom classifier from their own training data using the sandbag function. This will also be 
## necessary for other model organisms where pre-trained classifiers are not available. 也就是说对于特别
## 的建库方法，使用默认的训练集并不合适；亦或是其它模式动物，可以考虑使用sandbag函数来构建自己的训练集。

## 在进行细胞周期检测之前，不要将低表达gene滤除：Do not filter out low-abundance genes before applying 
## cyclone. Even if a gene is not expressed in any cell, it may still be useful for classification if 
## it is phase-specific. Its lack of expression relative to other genes will still yield informative pairs, 
## and filtering them out would reduce power.

################################### Examining gene-level expression metrics 对表达数据矩阵的探索 ###################################

#----------------------# Inspecting the most highly expressed genes 找到高表达的基因 #----------------------#

# We examine the identities of the most highly expressed genes (Figure 4). This should generally be dominated by 
# constitutively expressed transcripts, such as those for ribosomal or mitochondrial proteins. The presence of 
# other classes of features may be cause for concern if they are not consistent with expected biology. For example, 
# a top set containing many spike-in transcripts suggests that too much spike-in RNA was added during library preparation, 
# while the absence of ribosomal proteins and/or the presence of their pseudogenes are indicative of suboptimal alignment.
# 通常来讲，高表达的基因是和细胞生物学功能相关，或者是线粒体内或者核糖体基因。过高的spike-in不是好事情。
# 另外在高表达的gene里面，理论上应该有线粒体和核糖体相关基因以及他们的假基因，如果没有往往提示序列比对有问题。
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
plotQC(sce, type = "highest-expression", n=50) + fontsize  # 这一步可能会卡，最好先清一清内存空间
## Percentage of total counts assigned to the top 50 most highly-abundant features in the 416B dataset
## For each feature, each bar represents the percentage assigned to that feature for a single cell, while the circle 
## represents the average across all cells. Bars are coloured by the total number of expressed features in each cell, 
## while circles are coloured according to whether the feature is labelled as a control feature.


#----------------------# Filtering out low-abundance genes 过滤掉低丰度的基因 #----------------------#

# Several metrics can be used to define low-abundance genes. The most obvious is the average count for 
# each gene, computed across all cells in the dataset. We calculate this using the calcAverage() function, 
# which also performs some adjustment for library size differences between cells. We typically observe a 
# peak of moderately expressed genes following a plateau of lowly expressed genes (Figure 5).
# A minimum threshold can be applied to this value to filter out genes that are lowly expressed. The example 
# below demonstrates how we could remove genes with average counts less than 1. The number of TRUE values in 
# demo.keep corresponds to the number of retained rows/genes after filtering.
# 低丰度的基因因为表达量太低，从统计学上不足以提供足够的证据来拒绝零假设，而它们带来的影响确实增加了多重假设
# 检验的复杂性。因此在进行下游分析的时候需要排除这些低丰度基因（在进行细胞周期的鉴定之后）

# 在pData矩阵中的好几列都可以被用来定义低丰度基因。最显而易见的是每个基因的平均count数(across all cells)。我们
# 使用calcAverage()函数来进行计算，这个函数同时会对测序文库的大小进行一定程度的校正。通常情况下，在直方图中我们
# 可以看到中等表达基因会形成一个peak，而在左侧的低丰度区会有一个平台出现。
ave.counts <- calcAverage(sce, use_size_factors=FALSE)
hist(log10(ave.counts), breaks=100, main="", col="grey80", 
     xlab=expression(Log[10]~"average count"))
## 作者在进行直方图绘制的时候对其进行了log10的对数转换：Histogram of log-average counts for all genes in the 416B dataset

# 我们可以在此基础上设定一个最小的阈值，下面的例子是过滤掉那些平均count数小于1的gene。在summary的表格中，标记为TRUE
# 的gene是那些最终保留下来的gene/row
demo.keep <- ave.counts >= 1
filtered.sce <- sce[demo.keep,]
summary(demo.keep)

# 另外我们还会考虑每个gene分别在多少个细胞当中表达。这个数值通常会与gene的平均表达量是一致的，因为在大部分细胞中都有
# 的gene，往往表达丰度也很高。那些在很少的细胞当中表达的gene往往不是我们感兴趣的内容，因为他们被检测到往往是因为扩增
# 造成了artifact(当然我们也不能排除它们确实来自于非常少量的细胞中)。我们可以设定阈值来过滤掉那些只在<=n个细胞中表达
# 的基因。我们使用scater包中的函数nexprs()来进行计算。
# We also examine the number of cells that express each gene. This is closely related to the average 
# count for most genes, as expression in many cells will result in a higher average (Figure 6). Genes 
# expressed in very few cells are often uninteresting as they are driven by amplification artifacts 
# (though they may also also arise from rare populations). We could then remove genes that are 
# expressed in fewer than n cells. “Intensity of colour corresponds to the number of genes at any given location.”
num.cells <- nexprs(sce, byrow=TRUE)
smoothScatter(log10(ave.counts), num.cells, ylab="Number of cells",  # graphics基础包中的smoothScatter函数
              xlab=expression(Log[10]~"average count"))
## The number of cells expressing each gene in the 416B dataset, plotted against the log-average count
## Intensity of colour corresponds to the number of genes at any given location.


# We remove genes that are not expressed in any cell to reduce computational work in downstream steps. 
# Such genes provide no information and would be removed by any filtering strategy.
to.keep <- num.cells > 0
sce <- sce[to.keep,]
summary(to.keep)


############################## Normalization of cell-specific biases 去除混杂因素 ##############################

#----------------------# Using the deconvolution method to deal with zero counts 使用逆卷积方法去除零counts #----------------------#

# Read counts与测序的时候的捕获效率以及测序深度有关，正确的normalization可以在进行下游分析之前去除来自细胞的bias。这一步
# 的完成往往基于一个假设，即大部分的gene不存在差异表达，而在这些非差异表达的gene中出现系统性的count size的差别，我们认为
# 是来自于bias，需用通过scaling的方式进行解决。更具体的说，使用size factor量化因子可以表征每个gene在每个测序文库（细胞）中
# 需要scaling的程度。
# 计算量化因子的方法有很多，比如DESeq2包中的estimateSizeFactorsFromMatrix函数，和来自edgeR包中的calcNormFactors函数。
# 然而单细胞数据与bulk数据最大的差异在于单细胞数据的zera inflation。为了解决这个问题，我们将所有细胞的count 合起来从而
# 增加count size，这样能够更加准确的估计量化因子。然后将合起来的量化因子在deconvolute（分解）into cell-based factors for 
# cell-specific normalization.
# Single-cell data can be problematic for these bulk data-based methods (DESeq2 and edgeR normalization) due 
# to the dominance of low and zero counts. To overcome this, we pool counts from many cells to increase the 
# count size for accurate size factor estimation (Lun, Bach, and Marioni 2016). Pool-based size factors are 
# then “deconvolved” into cell-based factors for cell-specific normalization.
sce <- computeSumFactors(sce)  # 这样的一步操作完成了pooling和deconvoluting两个步骤
?computeSumFactors  # Methods to normalize single-cell RNA-seq data by deconvolving size factors from cell pools.
sizeFactors(sce)
summary(sizeFactors(sce))

# 我们通过下图发现量化因子和测序文库的大小是呈现正相关的。这也提示了大部分细胞之间的系统误差是来自于序列的捕获效率和测序深度的不同。
# 细胞之间的差异表达会产生一个在测序总counts数和量化因子之间的非线性trend，并且increased scatter around the trend。 我们举一个例子：
# 在癌基因激活以后量化因子会总体/系统性的减小，这与癌基因激活以后大部分基因出现上调，导致的组成行bias是有关的。
plot(sce$total_counts/1e6, sizeFactors(sce), log="xy",
     xlab="Library size (millions)", ylab="Size factor",
     col=c("red", "black")[sce$Oncogene], pch=16)
legend("bottomright", col=c("red", "black"), pch=16, cex=1.2,
       legend=levels(sce$Oncogene))
## Size factors from deconvolution, plotted against library sizes for all cells in the 416B dataset
## Axes are shown on a log-scale. Wild-type cells are shown in black and oncogene-induced cells are shown in red.

## 尽管deconvolution方法处理大量zero的单细胞数据表现不错，但是如果zero实在太多，其结果也会是fail的，它的具体表现为产生
## 了很多负的size factor。为了避免这样的问题，computeSumFactors函数会自动在计算量化因子之前过滤掉低丰度的gene，这个阈值
## 手工来设定，使用参数min.mean=。经过测序文库校正后的average count低于这个阈值的会被过滤掉。
## 在设定这个阈值的时候，对于read counts数据，可以设的相对高一点，比如1；而对于UMI数据，可以设的相对低一点，比如0.1.
## 我们在进行gene QC之前，一定要先进行cell QC来过滤掉低expressed genes的细胞，如果不事先做这一步，那么computeSumFactors函数
## 返回的结果在低质量细胞中会有大量的负值。

## sizes参数用来指定将多少个细胞pool到一起来计算size factors。sizes越大，产生的估计结果就越准确，当然是以计算的时间和存储
## 空间为代价的。当然，sizes不要小于20，这样能够确保在每个pool当中有足够的非零数值。作者在这边建议总的细胞数量不应该小于100。

## 对于异质性非常明显的数据集，作者推荐使用粗的clustering方法。可以使用quickCluster函数，然后使用cluster参数将结果传递
## 到computeSumFactor中。在每一个cluster当中的细胞会单独进行normalization，然后量化因子会重新scaled，最终使结果在不同的
## cluster是可以比较的。这样做的好处是可以避免假设大部分的基因在细胞群体中是非差异表达的，在进行cluster的组间比较的时候才需要
## 假设大部分基因是非差异表达的。这个方法会在上面UMI的数据（Amit Zeisel的数据集进行演示）。

#----------------------# Computing separate size factors for spike-in transcripts 对spike-in计算量化因子 #----------------------#
# 针对内源基因和spike-in序列的量化因子的计算是不同的：
# 通过内源基因计算的量化因子通常情况下不能适用于spike-in序列的normalization。存在更多RNA的细胞的内源基因的count数会增多，因此需要
# 更大的size factor把counts scale down。然而在建库的时候，使用spike-in通常是将相同量的spike-in RNA添加到每个细胞当中去。这就意味着
# spike-in的counts数是不受内源RNA的影响的。使用内源基因的size factor来normalize spike-in会导致spike-in的over-normalization和最终
# 导致计数错误。对于一个不变的cDNA量，任何内源RNA的量的增加会导致spike-in转录本的覆盖率的降低。因此，spike-in的量会与内源基因的
# 量化以你呈现负相关的关系。
# 为了确保正确的normalization，我们针对spike-in计算独立的size factor。它被定义为all transcripts in spike-in set的total counts。
# 它基于的假设是任何一个spike-in transcript都不会是差异表达的，这是合乎情理的，因为实际上每个细胞添加了相同数量和组成的spike-in RNA。
# 针对spike-in的量化因子会存储在SingleCellExperiment对象的一个独立的field当中（通过在computeSpikeFactors函数中的general.use = FALSE进行设定）
# 这能够确保是专门针对spike-in的，而不是针对内源基因的。
sce <- computeSpikeFactors(sce, type="ERCC", general.use=FALSE)

#----------------------# Applying the size factors to normalize gene expression 使用量化因子来对基因表达量进行校正 #----------------------#

# count data用于计算normalized log-expression，后者用于下游的分析。这里面每一个数值的含义是log2-ratio of each count to the size factor
# for the corresponding cell, after adding a prior count of 1 to avoid undefined values at zero count.翻译成中文，就是每一个数值加1
# 然后通过size factor进行归一化，然后log2对数转换。通过除以size factor可以确保细胞特异的bias会被remove掉。如果我们实现计算了spike-in
# 特异的量化因子并存储到了sce对象当中，它们会被自动加载用来专门归一化spike-in序列。
sce
sce <- normalize(sce)
sce  # 增加了logcounts这个slot，同时metadata增加了log.exprs.offset这个slot
## log转化的好处是两个log数值的差值就直接反应了log2 fold change。这比绝对数要更优的原因是绝对数的解释是需要基于overall abundance的。
## 另外log转化是variance能够更加稳定，这样离散度大，同时表达量高的gene不会在下游的分析中起到过分强大的作用。计算得到的结果会存储到logcounts
## 这个slot里面。

########################### Modelling the technical noise in gene expression 找到数据中的technical noise ###########################

#----------------------# Fitting a trend to the spike-in variances 通过spike-in拟合出technical noise #----------------------#

# Variability in the observed expression values across genes can be driven by genuine biological heterogeneity 
# or uninteresting technical noise. To distinguish between these two possibiltiies, we need to model the 
# technical component of the variance of the expression values for each gene. We do so using the set of 
# spike-in transcripts, which were added in the same quantity to each cell. Thus, the spike-in transcripts 
# should exhibit no biological variability, i.e., any variance in their counts should be technical in 
# origin.
# 基因表达在细胞间的差异可以来自于真实的生物学的异质性，或者来源于我们不感兴趣的technical noise，我们的目的是把technical noise
# 从中给分离出来。因为我们在每个细胞使用的同一套，并且是相同剂量的spike-in，因此spike-in转录本的差别必然不是来自于生物学上的差别，
# 也就是说spike-in的variance是来自于technical。

# We use the trendVar() function to fit a mean-dependent trend to the variances of the log-expression values for the spike-in 
# transcripts. We set block= to block on the plate of origin for each cell, to ensure that technical differences between plates 
# do not inflate the variances. Given the mean abundance of a gene, the fitted value of the trend is then used as an estimate of 
# the technical component for that gene. The biological component of the variance is finally calculated by subtracting the 
# technical component from the total variance of each gene with the decomposeVar function.
# 我们使用trendVar函数来拟合spike-in的表达平均值和log转换后的variance。variance当中的生物学成分是在每个基因中，通过total variance中减去technical
# component得到的，实现它的函数是decomposeVar函数。
var.fit <- trendVar(sce, parametric=TRUE, block=sce$Plate,
                    loess.args=list(span=0.3))
var.out <- decomposeVar(sce, var.fit)
head(var.out)

# We visually inspect the trend to confirm that it corresponds to the spike-in variances (Figure 8)). 
# The wave-like shape is typical of the mean-variance trend for log-expression values. A linear 
# increase in the variance is observed as the mean increases from zero, as larger variances are 
# possible when the counts increase. At very high abundances, the effect of sampling noise decreases 
# due to the law of large numbers, resulting in a decrease in the variance.
# 我们通常会可视化一下这个trend来看基因之间的差异和spike-in的variance（technical variance）有多少相关性。
# 我们通常会看到一个波状（先上升后下降）的图，当平均表达量从0逐渐增加时，variance也会线性增加直到到了一个
# 最大的variance（顶点），然而对于那些丰度非常高的gene，sampling noise effect会降低（因为不会有dropout吧）
# 因此variance也会随之降低
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
     ylab="Variance of log-expression")
curve(var.fit$trend(x), col="dodgerblue", lwd=2, add=TRUE)
cur.spike <- isSpike(sce)
points(var.out$mean[cur.spike], var.out$total[cur.spike], col="red", pch=16)
## Variance of normalized log-expression values for each gene in the 416B dataset, plotted against the mean log-expression
## The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).
## 蓝线是根据红色的spike-in你和出来的一条线。

# We check the distribution of expression values for the genes with the largest biological components. 
# This ensures that the variance estimate is not driven by one or two outlier cells (Figure 9).
# 我们查看一下那些拥有最大的生物学variance的gene的表达情况，这可以让我们确认高variance并不是因为1个或几个outlier细胞
# 所造成的。
chosen.genes <- order(var.out$bio, decreasing=TRUE)[1:10]
plotExpression(sce, features=rownames(var.out)[chosen.genes]) + fontsize
## Violin plots of normalized log-expression values for the top 10 genes with the largest biological components in the 416B dataset
## Each point represents the log-expression value in a single cell.


#----------------------# Choosing the parameters of the trend fit 在拟合过程中如何选择参数 #----------------------#





################################ Removing the batch effect ################################
# 这批数据来源于两盘细胞，在处理两盘细胞过程中哪怕一些细微的差别也会导致批次效应的产生（比如两盘细胞系统性的表达差异）
# 我们可以使用limma包中的removeBatchEffect()函数来去除批次效应。这可以去除因为来自不同盘的细胞造成的差异，同时又保留了
# 我们感兴趣的effect造成的不同细胞间的表达差异。
library(limma)
assay(sce, "corrected") <- removeBatchEffect(logcounts(sce), 
                                             design=model.matrix(~sce$Oncogene), batch=sce$Plate)
assayNames(sce)
## 手动的校正批次效应对下游not model-based的分析十分重要（包括clustering和降维）。然而如果一个方法能够接受一个design matrix
## 那么block掉一些不感兴趣的因素是非常建议操作的，我们推荐那些方法而不是使用removeBatchEffect()。这是因为后者并没有将残差丢失
## 的自由度考虑进去，也没有考虑blocking factor的估计值的不确定性。
## removeBatchEffect()函数是构建了一个线性回归模型，并给予blocking factors和zero一个coefficient。然而使用这个方法的前提是
## 每一个batch的细胞组成是已知的，并且不同batch之间是相同的。然而，对于大部分的scRNA-seq，造成差异的factors在不同batch之间是不同的
## 并且是事先不知道的。这就促使我们使用更加优良的校正batch的方法，比如mnnCorrect().

############################## Denoising expression values using PCA ##############################
# Once the technical noise is modelled, we can use principal components analysis (PCA) to remove random technical noise.
# We assume that biological processes involving co-regulated groups of genes will account for the 
# most variance in the data. If this is the case, this process should be represented by one or more 
# of the earlier PCs. In contrast, random technical noise affects each gene independently and will be 
# represented by later PCs. The denoisePCA() function removes later PCs until the total discarded 
# variance is equal to the sum of technical components for all genes used in the PCA.

# 在减少了背景噪声（某些基因）的基础上，对数据进行进一步降维（一般降维到原来维度的4-7%），以进一步去除背景噪音
# 怎样来理解靠前的PC有用，靠后的PC没啥用呢？我们还是要从生物学角度出发进行思考：
# 具有共调控模式的基因，往往聚集在/贡献在同一个biological process里面，而这些gene是造成细胞之间差别的主要因素，反映到
# 数据上是造成数据差异的主要原因（或者说解释了数据主要的变异），这些process从理论上应该被靠前的PC捕获/识别到。相反，随机的
# technical noise往往是独立影响单个gene，因此对于数据的差异贡献度小，会从靠后的PC捕获到。我们使用denoisePCA()函数来删除
# 靠后的PC，until the total discarded variance is equal to the sum of technical components for all genes used in the PCA.
# denoisePCA() will only use genes that have positive biological components, i.e., variances greater 
# than the fitted trend. This guarantees that the total technical variance to be discarded will not 
# be greater than the total variance in the data. 所以上面modeling technical noise一部是必须先执行的。

# No filtering is performed on abundance here, which ensures that PCs corresponding to rare subpopulations 
# can still be detected. Discreteness is less of an issue as low-abundance genes also have lower variance, 
# thus reducing their contribution to the PCA.
# denoisePCA()函数只使用那些biological component为正值的基因，即variance要超过fitted trend。这能够确保总的被舍弃的techncial
# variance不会大于数据的total variance。
sce <- denoisePCA(sce, technical=var.fit$trend, assay.type="corrected")
dim(reducedDim(sce, "PCA")) 
## 返回的结果保存在SingleCellExperiment对象当中的reduceDims这个slot当中，它存储了针对每个细胞的PC score（可以用来画散点图了吧，
## 理论上相当于坐标）。这一步操作能够消除technical noise并且尽量富集真正造成生物学影响的PC，这回对后续分析，比如clustering，增加
## 分析的分辨率。

# It is also possible to obtain a low-rank approximation of the original expression matrix, capturing 
# the variance equivalent to the retained PCs. This is useful for denoising prior to downstream 
# procedures that require gene-wise expression values.
# 什么叫low-rank approximation？得问问，另外增加了lowrank这个表达slot。
sce2 <- denoisePCA(sce, technical=var.fit$trend, 
                   assay.type="corrected", value="lowrank") 
assayNames(sce2)

######################## Data exploration with dimensionality reduction 数据降维后对数据进行探索 #######################
# We visualize the relationships between cells by constructing pairwise PCA plots for the first three 
# components (Figure 10). Cells with similar expression profiles should be located close together in 
# the plot, while dissimilar cells should be far apart. In this case, we observe a clear separation 
# of cells based on the oncogene induction status, consistent with the expected effects on the transcriptome.
# 不同的颜色可以区分(induced or control)
plotReducedDim(sce, use_dimred="PCA", ncomponents=3, 
               colour_by="Oncogene") + fontsize
## Pairwise PCA plots of the first three PCs in the 416B dataset, constructed from normalized log-expression values of genes with positive biological components
## Each point represents a cell, coloured according to oncogene induction status

# By comparison, we observe no clear separation of cells by batch (Figure 11). This indicates that 
# our batch correction step using removeBatchEffect() was successful. 
# 不同颜色(batch)应该搅合在一起，这说明我们通过batch的校正很好。
plotReducedDim(sce, use_dimred="PCA", ncomponents=3, 
               colour_by="Plate") + fontsize
## Pairwise PCA plots of the first three PCs in the 416B dataset, constructed from normalized log-expression values of genes with positive biological components
## Each point represents a cell, coloured according to the plate of origin.

# Another widely used approach for dimensionality reduction is the t-stochastic neighbour embedding 
# (t-SNE) method (Van der Maaten and Hinton 2008). t-SNE tends to work better than PCA for separating 
# cells in more diverse populations. This is because the former can directly capture non-linear 
# relationships in high-dimensional space, whereas the latter must represent them on linear axes. 
# However, this improvement comes at the cost of more computational effort and requires the user to
# consider parameters such as the random seed and perplexity (see comments). We demonstrate the 
# generation of t-SNE plots in Figure 12, using the low-rank approximation of the data to take 
# advantage of the denoising step. 
# 我们需要自己定义perplexity
run_args <- list(rand_seed=100, use_dimred="PCA")
out5 <- plotTSNE(sce, run_args=c(run_args, perplexity=5),
                 colour_by="Oncogene") + fontsize + ggtitle("Perplexity = 5")

out10 <- plotTSNE(sce, run_args=c(run_args, perplexity=10),
                  colour_by="Oncogene") + fontsize + ggtitle("Perplexity = 10")

out20 <- plotTSNE(sce, run_args=c(run_args, perplexity=20),
                  colour_by="Oncogene") + fontsize + ggtitle("Perplexity = 20")

multiplot(out5, out10, out20, cols=3)
## t-SNE plots constructed from the denoised PCs in the 416B dataset, using a range of perplexity values
## Each point represents a cell, coloured according to its oncogene induction status. Bars represent the coordinates of the cells on each axis.

## There are many other dimensionality reduction techniques that we do not consider here but could 
## also be used, e.g., multidimensional scaling, diffusion maps. These have their own advantages and 
## disadvantages – for example, diffusion maps (see plotDiffusionMap) place cells along a continuous 
## trajectory and are suited for visualizing graduated processes like differentiation
## diffusionmap也是一种数据降维方法，是将细胞投射到一个连续的trajectory上面，这个方法很适合用来可视化连续的过程
## 比如发育。
plotDiffusionMap(sce, colour_by="Oncogene") # 仅仅作为一个演示。

## t-SNE is a stochastic method, so users should run the algorithm several times to ensure that the 
## results are representative. Scripts should set a seed (via the  rand_seed argument) to ensure 
## that the chosen results are reproducible. It is also advisable to test different settings of the 
## “perplexity” parameter as this will affect the distribution of points in the low-dimensional 
## space. A good guide on how to interpret t-SNE plots can be found at http://distill.pub/2016/misread-tsne/.
## 在使用t-SNE的时候建议多测试几次来看看结果是不是稳定，主要要set.seed，这样能够确保结果是可以重复的。
## 建议多尝试不同的perplexity，找到最佳的数值。




######################## Clustering cells into putative subpopulations ########################

#----------------------# Defining cell clusters from expression data 根据表达矩阵来定义cluster #----------------------#

# 大致策略是先用PCA降维去噪，计算距离矩阵，根据距离矩阵来进行clustering。其中使用Ward’s criterion可减少
# 同一个cluster的variance。然后使用动态剪切树的方法来进一步减少cluster的数量。然后在经过PCA降维的数据基础上
# 进行tSNE可视化以进一步区分不同的细胞，cluster是用距离矩阵和剪切数来定义的。
# 这种在去除背景噪音基因的基础上，再进行两次数据降维的方法（PCA降维后再用tSNE）非常适合可视化。

# 作者在这边采用的cluster策略变了，改成了经典的层级聚类，使用denoise的log-expression值，计算细胞之间的欧式距离，通过
# Ward's criterion来尽量减少每个cluster的total variance。最终会产生一个dendrogram，是根据chosen gene的相似表达模式，把
# 细胞进行聚类。
pcs <- reducedDim(sce, "PCA")
my.dist <- dist(pcs)
my.tree <- hclust(my.dist, method="ward.D2")

# 聚类是根据在dendrogram上进行动态剪切树，他可以采用dendrogram的shape来refine cluster，比cutree更适用于复杂的dendrogram；
# 在cutreeDynamic函数中，通过设定cutHeight能够更好的control树。通过设定minClusterSize，而不是采用默认的20，可以避免把细胞归位
# 互相分开的若干个小群。
library(dynamicTreeCut)
my.clusters <- unname(cutreeDynamic(my.tree, distM=as.matrix(my.dist), 
                                    minClusterSize=10, verbose=0))

# We examine the distribution of cells in each cluster with respect to known factors (plate). Each cluster is comprised of cells 
# from both batches, indicating that the clustering is not driven by a batch effect. Differences in the composition of 
# each cluster are observed with respect to  Oncogene, consistent with a biological effect of oncogene induction.
table(my.clusters, sce$Plate)

table(my.clusters, sce$Oncogene)

# We visualize the cluster assignments for all cells on the t-SNE plot in Figure 13. Adjacent cells are generally assigned 
# to the same cluster, indicating that the clustering procedure was applied correctly.
# 在t-SNE中，细胞之间的距离是根据t-SNE的结果，但是其赋予的颜色，则是根据cluster的结果（在这里是层级聚类），同一个颜色的点聚在
# 一堆，说明这个结果在两个算法是比较类似的，结果比较稳健可信。
sce$cluster <- factor(my.clusters)
plotTSNE(sce, run_args=list(use_dimred="PCA", perplexity=20, 
                            rand_seed=200), colour_by="cluster") + fontsize
## t-SNE plot of the denoised PCs of the 416B dataset
## Each point represents a cell and is coloured according to the cluster identity to which it was assigned.

# 接下来我们需要查看一下每个cluster之间区分度是否好，我们使用silhouette width来衡量。一个细胞，如果其silhouette的数值比较高，
# 这说明这个细胞与在同一个cluster的细胞的距离相比不同cluster的细胞的距离近，也就更能确定这个细胞是在这个cluster；相反，如果
# silhouette数值越低，就说明这个细胞离其它cluster中的细胞相比自己assign的cluster中的细胞近，结果相对不那么可靠。每个cluster必然
# 会存在一些具有比较高silhouette数值的细胞，意味着it is well-separeted from other clusters.
library(cluster)
clust.col <- scater:::.get_palette("tableau10medium") # hidden scater colours
sil <- silhouette(my.clusters, dist = my.dist)
sil.cols <- clust.col[ifelse(sil[,3] > 0, sil[,1], sil[,2])]
sil.cols <- sil.cols[order(-sil[,1], sil[,3])]
plot(sil, main = paste(length(unique(my.clusters)), "clusters"), 
     border=sil.cols, col=sil.cols, do.col.sort=FALSE) 
## Barplot of silhouette widths for cells in each cluster
## Each cluster is assigned a colour and cells with positive widths are coloured according to the colour of its assigned cluster. 
## Any cell with a negative width is coloured according to the colour of the cluster that it is closest to. The average width 
## for all cells in each cluster is shown, along with the average width for all cells in the dataset.

## 我们如何来评价上面这张silhouette plot呢
## 我么发现大部分的细胞的数值比较小（average = 0.16），这就意味着不同的cluster之间的不是很好的分开。这可能是由于over-clustering
## 导致的，比如oncogene induction status的又被细分成了一些小的subset，而这些subset是不那么好的区分开。使用silhouette width能够
## 帮助调整和优化参数（比如cut height，number of cluster)，从而来最大程度的将不同的cluster区分开。比如我们通过调整cut height或者
## splitting depth（在cutreeDynamic函数中）来最大化细胞的silhouette value. 然而在这里我们还是遵循现在的cluster scheme，毕竟它还是
## 提供了不错的partition。

## 还有其他的clustering的方法，比如通过计算correlation来得到距离矩阵（quickCluster）。这个方法对noise和normalization error更加稳健
## 但是对于表达谱的细微变化就不是很敏感了。
## 使用Ward's Criterion和complete linkage能够产生更加类似圆形的，密集的cluster。事实上complete linkage更倾向于产生半径相同的cluster。
## 这在某些情况下是理想的，但是当不同的subpopulation的variance是不同的时候，就不那么合适了。因此，通常来讲我们使用Ward's Criterion
## 来初始化clustering。当然，也建议采用别的方法，最后可以使用silhouette width来评估不同方法的好坏。


#----------------------# Detecting marker genes between clusters 发现每个cluster中的marker gene #----------------------#
# 1，Once putative subpopulations are identified by clustering, we can identify marker genes for each 
# cluster using the findMarkers function. This fits a linear model to the log-expression values for 
# each gene using limma (Ritchie et al. 2015). The aim is to test for DE in each cluster compared to 
# the others while blocking on uninteresting factors such as the plate of origin in design. The top 
# DE genes are likely to be good candidate markers as they can effectively distinguish between cells 
# in different clusters.
# findMarkers函数采用了linear model，对每个gene的log转换后的数值进行（内嵌了limma包）。这样可以规避你不感兴趣
# 的因素对最终结果的影响。在最后的列表里面高排位的DE genes是非常理想的marker genes因为它们可以帮助很好的区分不同
# 的细胞。


# 2, findMarkers can also be directed to find genes that are DE between the chosen cluster and all 
# other clusters. This should be done by setting pval.type="all", which defines the p-value for each 
# gene as the maximum value across all pairwise comparisons involving the chosen cluster. Combined 
# with direction="up", this can be used to identify unique markers for each cluster. However, this 
# is sensitive to overclustering, as unique marker genes will no longer exist if a cluster is split 
# into two smaller subclusters.
markers <- findMarkers(sce, my.clusters, block=sce$Plate)
markers
## It must be stressed that the (adjusted) p-values computed here cannot be properly interpreted as measures of 
## significance. This is because the clusters have been empirically identified from the data. limma does not account 
## for the uncertainty of clustering, which means that the p-values are much lower than they should be. This is not 
## a concern in other analyses where the groups are pre-defined.


# By setting direction="up", findMarkers will only return genes that are upregulated in each cluster compared to 
# the others. This is convenient in highly heterogeneous populations to focus on genes that can immediately 
# identify each cluster. While lack of expression may also be informative, it is less useful for positive identification.

# 找到针对你感兴趣的cluster与其它所有cluster的差异基因，这里面的FDR值是所有pairwise的p-value里面最大的：
# findMarkers can also be directed to find genes that are DE between the chosen cluster and all other clusters. 
# This should be done by setting pval.type="all", which defines the p-value for each gene as the maximum value 
# across all pairwise comparisons involving the chosen cluster. Combined with direction="up", this can be used 
# to identify unique markers for each cluster. However, this is sensitive to overclustering, as unique marker 
# genes will no longer exist if a cluster is split into two smaller subclusters.
# 弊端是在over-clustering的情况下，可能我们根本找不到这样的marker gene。
markers_strict <- findMarkers(sce, my.clusters, block=sce$Plate, pval.type= "all", direction = 'up')
markers_strict # 看一下fdr

# 我们还可以使用overlapExprs函数：
# The overlapExprs function may also be useful here, to prioritize candidates where there is clear separation between 
# the distributions of expression values of different clusters. This differs from findMarkers, which is primarily 
# concerned with the log-fold changes in average expression between clusters.

# For each cluster, the DE results of the relevant comparisons are consolidated into a single output 
# table. This allows a set of marker genes to be easily defined by taking the top DE genes from each 
# pairwise comparison between clusters. For example, to construct a marker set for cluster 1 from the 
# top 10 genes of each comparison, one would filter marker.set to retain rows with Top less than or 
# equal to 10. Other statistics are also reported for each gene, including the adjusted p-values (see 
# below) and the log-fold changes relative to every other cluster.
marker.set <- markers[["1"]]
head(marker.set, 10)

# We save the list of candidate marker genes for further examination.
write.table(marker.set, file="416B_marker_1.tsv", sep="\t", 
            quote=FALSE, row.names=FALSE)

# We visualize the expression profiles of the top candidates to verify that the DE signature is robust 
# (Figure 15). Most of the top markers have strong and consistent up- or downregulation in cells of 
# cluster 1 compared to some or all of the other clusters. A cursory examination of the heatmap 
# indicates that cluster 1 contains oncogene-induced cells with strong downregulation of DNA replication 
# and cell cycle genes. This is consistent with the potential induction of senescence as an 
# anti-tumorigenic response (Wajapeyee et al. 2010). A more comprehensive investigation of the 
# function of these markers can be performed with gene set enrichment analyses, e.g., using kegga 
# or goana from limma.
top.markers <- rownames(marker.set)[marker.set$Top <= 10]
plotHeatmap(sce, features=top.markers, columns=order(sce$cluster), 
            colour_columns_by=c("cluster", "Plate", "Oncogene"),
            cluster_cols=FALSE, center=TRUE, symmetric=TRUE, zlim=c(-5, 5))
## Heatmap of mean-centred and normalized log-expression values for the top set of markers for cluster 1 in 
## the 416B dataset
## Column colours represent the cluster to which each cell is assigned, the plate of origin or the oncogene 
## induction status of each cell, as indicated by the legend.

            
## 找到单一一个细胞类型特异表达的gene有的时候标准过于苛刻，在部分subpopulation存在DE就可以认为marker
## 通过上述方法，只要在至少一组subpopulation对里面是差异表达的，我们就认为是marker gene的候选。我们可以
## 之后选择一个combination of marker genes来定义subpopulation，这比找到可以定义唯一的细胞类型的marker
## 更加flexible。
## Many of the markers in Figure 15 are not uniquely up- or downregulated in the chosen cluster. 
## Testing for unique DE tends to be too stringent as it overlooks important genes that are expressed 
## in two or more clusters. For example, in a mixed population of CD4+-only, CD8+-only, double-positive 
## and double-negative T cells, neither Cd4 or Cd8 would be detected as subpopulation-specific markers 
## because each gene is expressed in two subpopulations. With our approach, both of these genes will 
## be picked up as candidate markers as they will be DE between at least one pair of subpopulations. 
## A combination of markers can then be chosen to characterize a subpopulation, which is more flexible 
## than trying to find uniquely DE genes.

#################################### Concluding remarks ####################################
saveRDS(file="416B_data.rds", sce)

# 其它方法：
# 针对pseudotime，我么可以使用monocle或者TSCAN。
# 细胞状态的层级可以使用sincell包来描绘。
# 可以使用Oscope包来描绘oscillatory behavior
# HVG和GO可以使用topGO和scde包



#==============================================================================================
#
#                3. Further strategies for analyzing single-cell RNA-seq data
#
#==============================================================================================

# This workflow will describe some analyses that were not covered in the previous workflows, using a variety of relevant 
# datasets (Wilson et al. 2015; Islam et al. 2011; Buettner et al. 2015) generated using a range of technologies. It 
# includes alternative parameter settings and options that are not usually used as default but may be helpful in some 
# circumstances.



######################################### 1. Overview #########################################
# The previous workflows focused on analyzing single-cell RNA-seq data with “standard” procedures. 
# However, a number of alternative parameter settings and strategies can be used at some steps of the 
# workflow. This workflow describes a few of these alternative settings as well as the rationale 
# behind choosing them instead of the defaults.
# 这个workflow主要关注针对不同情况下，参数的选择以及背后的原理。


##################################### 2. Quality control on cells #####################################

#----------------------# Assumptions of outlier identification 鉴定离群值的假设 #----------------------#
# 我们排除离群值（细胞）基于的假设是大部分细胞的质量是不错的。另外某些方法可以让我们通过肉眼来观察细胞状态是否完好。
# 但是在非常异质性的细胞群体当中，部分细胞的表达的RNA总量就是少，或者表达的基因种类就是少于其它细胞类型。这些细胞则
# 会被默认为离群细胞而被舍弃掉，即使实际上它们的质量非常高。使用MAD能够在一定程度上缓解这个问题，因为一团非常异质性的
# 细胞群会有非常高的variability，因而MAD的值就会比较大，因而会减少错误的排除高质量细胞的情况（其代价是减少排除低质量
# 细胞的power）。但是我们必须要注意，基于离群值的方法过滤细胞在非常极端的情况下，比如细胞的类型差别巨大的时候，不是
# 一种很好的方法。

# 我们也可以针对不同的batch进行离群值的鉴定：
# Systematic differences in the QC metrics can be handled to some extent using the batch= argument in the isOutlier() 
# function. For example, setting batch to the plate of origin will identify outliers within each level of batch, using 
# plate-specific median and MAD estimates. This is obviously useful for accommodating known differences in experimental 
# processing, e.g., sequencing at different depth or different amounts of added spike-in RNA. We can also include 
# biological factors in batch, if those factors could result in systematically fewer expressed genes or lower RNA content. 
# However, this is not applicable in experiments where the factors are not known in advance.


#----------------------# Checking for discarded cell types 仔细排查那些被丢弃的细胞 #----------------------#

## We can diagnose loss of distinct cell types during QC by looking for differences in gene expression 
## between the discarded and retained cells (Figure 1). If the discarded pool is enriched for a 
## certain cell type, we should observe increased expression of the corresponding marker genes. No 
## systematic upregulation of genes is apparent in the discarded pool in Figure 1, indicating that 
## the QC step did not inadvertently filter out a cell type in the 416B dataset.
## 我们可以通过比较丢弃的细胞和保留的细胞的表达差异来判断有没有排除某种类型的细胞。如果排除的细胞包括了某个
## 特定的细胞类型，我们会发现那个丢弃细胞的marker gene在丢弃细胞中高表达，但是在保留的细胞中是低表达的，我们在
## 下图中并没有看到一个系统性的在丢弃细胞中的上调基因，这也就以为着在QC步骤中排除的细胞并没有丢弃某个特定
## 的细胞类型。
setwd('/Users/mijiarui/Nature_Biotechnology_Paper/simpleSingleCell')
library(SingleCellExperiment)
sce.full.416b <- readRDS("416B_preQC.rds")

library(scater)
suppressWarnings({
  lost <- calcAverage(counts(sce.full.416b)[,!sce.full.416b$PassQC])
  kept <- calcAverage(counts(sce.full.416b)[,sce.full.416b$PassQC])
})
logfc <- log2((lost+1)/(kept+1))
head(sort(logfc, decreasing=TRUE), 20)


# Each point represents a gene, with spike-in and mitochondrial transcripts in red and blue respectively.
plot(lost, kept, xlab="Average count (discarded)", 
     ylab="Average count (retained)", log="xy", pch=16, 
     main = 'Average counts across all discarded and retained cells in the 416B dataset')
is.spike <- isSpike(sce.full.416b)
points(lost[is.spike], kept[is.spike], col="red", pch=16)
is.mito <- rowData(sce.full.416b)$is_feature_control_Mt
points(lost[is.mito], kept[is.mito], col="dodgerblue", pch=16)


# By comparison, a more stringent filter in the PBMC dataset would remove the previously identified 
# platelet population (see the previous workflow). This manifests in Figure 2 as a shift to the 
# bottom-right for a number of genes, including PF4 and PPBP.
# 相反在PBMC的数据集中，我们采用了更加激进的filter策略，从而把血小板给滤除了。在下方的散点图中我们看到有
# 这么几个基因分布的位置朝着右下方漂移，这些基因分别是PF4和PPBP，也就意味着这几个gene在discarded cell中
# 是富集的，但是在retained cells中是低表达的。
sce.pbmc <- readRDS("pbmc_data.rds")
wrong.keep <- sce.pbmc$total_counts >= 1000
suppressWarnings({
  lost <- calcAverage(counts(sce.pbmc)[,!wrong.keep])
  kept <- calcAverage(counts(sce.pbmc)[,wrong.keep])
})
logfc <- log2((lost+1)/(kept+1))
head(sort(logfc, decreasing=TRUE), 20)


plot(lost, kept, xlab="Average count (discarded)", 
     ylab="Average count (retained)", log="xy", pch=16)
platelet <- c("PF4", "PPBP", "SDPR")
points(lost[platelet], kept[platelet], col="orange", pch=16)
## Average counts across all discarded and retained cells in the PBMC dataset
## Each point represents a gene, with platelet-related genes highlighted in orange.

# 如果我们发现有一些细胞被错误的舍弃，我们能做的就是放宽过滤条件。我们可以通过增大isOutlier函数
# 中的nmads=参数或者干脆就不filter。但是我们也需要铭记，保留过多的低质量细胞会增加所谓的显性异质
# 性，这会影响后续的variance modeling和PCA，因为靠前的几个PC可能是反映的测序质量，而非生物学差异。
# 最差的情况是，低质量的细胞会自动归位一个cluster，这对于结果的解释需要额外的关注。这也促使我们
# 在一开始还是更倾向于采用比较严格的filtering策略。

#----------------------# Alternative approaches to quality control QC的一些其它方法 #----------------------#
# 使用fixed threshold
## 比如我们可以设定排除library size小于100000和检出基因小于4000的细胞。这需要我们有足够的经验来判断合适的阈值
## 的选取。我们需要牢记，针对read counts的阈值是不适用于UMI data的；反之亦然。即使使用的相同的protocol和系统
## 每次/run的分析采用的threshold都可能是不同的，这是因为每次的RNA capture效率和测序深度是不一样的。


# Using PCA-based outliers
# Another strategy is to perform a principal components analysis (PCA) based on the quality metrics 
# for each cell, e.g., the total number of reads, the total number of features and the proportion of 
# mitochondrial or spike-in reads. Outliers on a PCA plot may be indicative of low-quality cells that 
# have aberrant technical properties compared to the (presumed) majority of high-quality cells. This 
# is demonstrated below on a brain cell dataset from Tasic et al. (2016), using functions from the 
# scater package (McCarthy et al. 2017).
# 我们可以根据quality matrix对细胞进行PCA分析，outliers可能是低质量细胞。

# Obtaining the dataset.
library(scRNAseq)
data(allen)

# Setting up the data.
sce.allen <- as(allen, "SingleCellExperiment")
assayNames(sce.allen) <- "counts"
isSpike(sce.allen, "ERCC") <- grep("ERCC", rownames(sce.allen))

# Computing the QC metrics and running PCA.
library(scater)
sce.allen <- calculateQCMetrics(sce.allen)
sce.allen <- runPCA(sce.allen, use_coldata=TRUE, detect_outliers=TRUE)
table(sce.allen$outlier)

## 基于PCA或者支持向量机SVM的方法能够更加有效的检测出低质量细胞，这是因为它们能够更加敏感的找到subtle pattern across many
## quality metrics。但是在进行解释的时候，会有一定的困难；当然outliers也可以根据表达矩阵的PCA来实现，但是我们认为这个方法
## 比较risky，这是因为我们有排除高质量的罕见细胞群的可能。

################################## 3. Normalizing based on spike-in coverage 使用spike-in进行normalization ##################################

#----------------------# Motivation 为什么要用spike-in进行normalization #----------------------# 

# 在单细胞转录组测序中，进行scaling normalization的方法可以大致分成两类。第一类是基于一个假设，即样本之间有相当一部分基因是不存在差异表达的。
# 第二类方法则是通过向细胞中加入相同数量和序列的spike-in来进行校正。其中使用spike-in的方法中，我们认为最后测序得到的各样品之间spike-in序列的
# 的量的多少是来自于系统误差（cell-specific biases），比如序列捕获的效率和测序的深度。那在内源基因中排除spike-in的成分就可以减少这种系统误差。

# 选择哪一种方法进行normalization是取决于你的生物学问题和你感兴趣的东西。如果大部分基因是差异表达的，同时你无法找到一组可靠稳定的管家基因集的时候
# 使用spike-in的方法可能是唯一的去除cell-specific biases的方法。另外对于那些细胞中RNA总量在单个细胞中相差比较大，同时这也是你感兴趣的问题的时候，
# 我们也应该使用spike-in（比如肿瘤）。在任何一个特定的细胞当中，内源基因的增加并不会影响spike-in序列的多少（在测序前实际的量和建库测序后的量）。
# 因此，内源基因的多少的差别并不会成为spike-in定量过程中的biases，这也就以为着使用spike-in，并使用spike-in进行scaling并不会把细胞中RNA总量和表达
# 丰度的属性给掩盖掉。With non-DE normalization, an increase in RNA content will systematically increase the expression of all genes in the non-DE 
# subset, such that it will be treated as bias and removed.

#----------------------# Setting up the data 构建数据对象 #----------------------# 
# 我们使用的是Islam的数据集，包括mESCs和MEFs。
# We load the counts into R, using colClasses to speed up read.table by pre-defining the type of each column. 
# We also specify the rows corresponding to spike-in transcripts.
library(SingleCellExperiment)
counts <- read.table("GSE29087_L139_expression_tab.txt.gz", 
                     colClasses=c(list("character", NULL, NULL, NULL, NULL, NULL, NULL), 
                                  rep("integer", 96)), skip=6, sep='\t', row.names=1)

is.spike <- grep("SPIKE", rownames(counts)) 
sce.islam <- SingleCellExperiment(list(counts=as.matrix(counts)))
isSpike(sce.islam, "spike") <- is.spike
dim(sce.islam)

# 我们通过calculateQCMetrics来过滤掉低质量细胞。我们滤除每个细胞类型的outliers。其中Negative control wells
# 不包含任何细胞类型，因此用于质控（they should manifest as outliers for the various metrics)。在下游分析
# 的时候需要被滤除。
library(scater)
sce.islam <- calculateQCMetrics(sce.islam)
sce.islam$grouping <- rep(c("mESC", "MEF", "Neg"), c(48, 44, 4))

libsize.drop <- isOutlier(sce.islam$total_counts, nmads=3, type="lower", 
                          log=TRUE, batch=sce.islam$grouping)
feature.drop <- isOutlier(sce.islam$total_features, nmads=3, type="lower", 
                          log=TRUE, batch=sce.islam$grouping)
spike.drop <- isOutlier(sce.islam$pct_counts_spike, nmads=3, type="higher", 
                        batch=sce.islam$grouping)

sce.islam <- sce.islam[,!(libsize.drop | feature.drop | 
                            spike.drop | sce.islam$grouping=="Neg")]
data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop),
           BySpike=sum(spike.drop), Remaining=ncol(sce.islam))


#----------------------# Calculating spike-in size factors 计算spike-in的size factor 用来去除technical noise #----------------------# 
# 我们使用computeSpikeFactors函数来计算spike-in的size factor。这个方式是计算每个细胞中spike-in测序得到的total counts，这个
# size-factor就是基于细胞的总的spike-in count。我们使用general.use=TRUE参数，针对所有的spike-in
library(scran)
sce.islam <- computeSpikeFactors(sce.islam, general.use=TRUE)

# 接下来我们使用normalize函数，它会使用spike-in based factors来计算normalized log-expression。
# Unlike the previous analyses, we do not have to define separate size factors for the spike-in transcripts. This is 
# because the relevant factors are already being used for all genes and spike-in transcripts when general.use=TRUE. 
# (The exception is if the experiment uses multiple spike-in sets that behave differently and need to be normalized separately.)
sce.islam
sce.islam <- normalize(sce.islam)
sce.islam

# 为了比较，我们也计算deconvolution size factor，然后把它们和spike-in factors绘制在一张图上。
# We observe a negative correlation between the two sets of values (Figure 3). This is because MEFs contain more endogenous RNA, 
# which reduces the relative spike-in coverage in each library (thereby decreasing the spike-in size factors) but increases the 
# coverage of endogenous genes (thus increasing the deconvolution size factors). If the spike-in size factors were applied to the 
# counts, the expression values in MEFs would be scaled up while expression in mESCs would be scaled down. However, the opposite 
# would occur if deconvolution size factors were used.
par(mfrow = c(1,1))
colours <- c(mESC="red", MEF="grey")
deconv.sf <- computeSumFactors(sce.islam, sf.out=TRUE, cluster=sce.islam$grouping)
plot(sizeFactors(sce.islam), deconv.sf, col=colours[sce.islam$grouping], pch=16, 
     log="xy", xlab="Size factor (spike-in)", ylab="Size factor (deconvolution)")
legend("bottomleft", col=colours, legend=names(colours), pch=16)
## Size factors from spike-in normalization, plotted against the size factors from deconvolution for all cells in the mESC/MEF dataset
## Axes are shown on a log-scale, and cells are coloured according to their identity. Deconvolution size factors were computed with small 
## pool sizes owing to the low number of cells of each type.

# Whether or not total RNA content is relevant – and thus, the choice of normalization strategy – depends on the biological hypothesis. 
# In the HSC and brain analyses, variability in total RNA across the population was treated as noise and removed by non-DE normalization. 
# This may not always be appropriate if total RNA is associated with a biological difference of interest. For example, Islam et al. (2011) 
# observe a 5-fold difference in total RNA between mESCs and MEFs. Similarly, the total RNA in a cell changes across phases of the cell cycle 
# (Buettner et al. 2015). Spike-in normalization will preserve these differences in total RNA content such that the corresponding biological 
# groups can be easily resolved in downstream analyses.

# We only use genes with average counts greater than 1 (as specified in min.mean) to compute the deconvolution size factors. This avoids 
# problems with discreteness as mentioned in our previous uses of computeSumFactors.
# Setting sf.out=TRUE will directly return the size factors, rather than a  SingleCellExperiment object containing those factors. This is 
# more convenient when only the size factors are required for further analysis.

###################################### 4. Detecting highly variable genes #####################################

#----------------------# Setting up the data 构建数据对象 #----------------------# 

# HVGs是真正表针细胞表达差异并造成生物学异质性的gene，因而理应作为下游分析的首选对象。
# To demonstrate, we use data from haematopoietic stem cells (HSCs) (Wilson et al. 2015), generated using the 
# Smart-seq2 protocol (Picelli et al. 2014) with ERCC spike-ins. Counts were obtained from NCBI GEO as a supplementary 
# file using the accession number GSE61533. Our first task is to load the count matrix into memory. In this case, some 
# work is required to retrieve the data from the Gzip-compressed Excel format.
library(R.utils)
gunzip("GSE61533_HTSEQ_count_results.xls.gz", remove=FALSE, overwrite=TRUE)
library(gdata)
all.counts <- read.xls('GSE61533_HTSEQ_count_results.xls', sheet=1, header=TRUE)
rownames(all.counts) <- all.counts$ID
all.counts <- as.matrix(all.counts[,-1])

# We store the results in a SingleCellExperiment object and identify the rows corresponding to the spike-ins based on the row names.
sce.hsc <- SingleCellExperiment(list(counts=all.counts))
dim(sce.hsc)

is.spike <- grepl("^ERCC", rownames(sce.hsc))
isSpike(sce.hsc, "ERCC") <- is.spike
summary(is.spike)

# For each cell, we calculate quality control metrics using the calculateQCMetrics function as previously described. 
# We filter out HSCs that are outliers for any metric, under the assumption that these represent low-quality libraries.
sce.hsc <- calculateQCMetrics(sce.hsc)
libsize.drop <- isOutlier(sce.hsc$total_counts, nmads=3, type="lower", log=TRUE)
feature.drop <- isOutlier(sce.hsc$total_features, nmads=3, type="lower", log=TRUE)
spike.drop <- isOutlier(sce.hsc$pct_counts_ERCC, nmads=3, type="higher")
sce.hsc <- sce.hsc[,!(libsize.drop | feature.drop | spike.drop)]
data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop),
           BySpike=sum(spike.drop), Remaining=ncol(sce.hsc))

# We remove genes that are not expressed in any cell to reduce computational work in downstream steps.
to.keep <- nexprs(sce.hsc, byrow=TRUE) > 0
sce.hsc <- sce.hsc[to.keep,]
summary(to.keep)

# We apply the deconvolution method to compute size factors for the endogenous genes (Lun, Bach, and Marioni 2016). 
# Separate size factors for the spike-in transcripts are also calculated, as previously discussed. We then calculate 
# log-transformed normalized expression values for further use.
sce.hsc <- computeSumFactors(sce.hsc)
summary(sizeFactors(sce.hsc))

sce.hsc <- computeSpikeFactors(sce.hsc, type="ERCC", general.use=FALSE)
summary(sizeFactors(sce.hsc, "ERCC"))

sce.hsc <- normalize(sce.hsc)

#----------------------# Testing for significantly positive biological components #----------------------#
# We fit a mean-variance trend to the spike-in transcripts to quantify the technical component of the variance, 
# as previously described. The biological component for each gene is defined as the difference between its total 
# variance and the fitted value of the trend (Figure 4).

var.fit <- trendVar(sce.hsc, parametric=TRUE, loess.args=list(span=0.3))
var.out <- decomposeVar(sce.hsc, var.fit)
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
     ylab="Variance of log-expression")
curve(var.fit$trend(x), col="dodgerblue", lwd=2, add=TRUE)
cur.spike <- isSpike(sce.hsc)
points(var.out$mean[cur.spike], var.out$total[cur.spike], col="red", pch=16)
## Variance of normalized log-expression values for each gene in the HSC dataset, plotted against the mean log-expression
## The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).

# 这边对HVG的定义是：biological component显著大于0，使用FDR为5%
hvg.out <- var.out[which(var.out$FDR <= 0.05),]
nrow(hvg.out)

# We rank the results to focus on genes with larger biological components. This highlights an interesting aspect of 
# the underlying hypothesis test, which is based on the ratio of the total variance to the expected technical variance. 
# Ranking based on p-value tends to prioritize HVGs that are more likely to be true positives but, at the same time, 
# less likely to be interesting. This is because the ratio can be very large for HVGs that have very low total variance 
# and do not contribute much to the cell-cell heterogeneity.
hvg.out <- hvg.out[order(hvg.out$bio, decreasing=TRUE),] 
write.table(file="hsc_hvg.tsv", hvg.out, sep="\t", quote=FALSE, col.names=NA)
head(hvg.out)

# We check the distribution of expression values for the genes with the largest biological components. This ensures 
# that the variance estimate is not driven by one or two outlier cells 
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
plotExpression(sce.hsc, features=rownames(hvg.out)[1:10]) + fontsize
## Violin plots of normalized log-expression values for the top 10 genes with the largest biological components in the HSC dataset
## Each point represents the log-expression value in a single cell.

## There are many other strategies for defining HVGs, based on a variety of metrics:
## the coefficient of variation (Brennecke et al. 2013; Kołodziejczyk et al. 2015; Kim et al. 2015)
## the dispersion parameter in the negative binomial distribution (McCarthy, Chen, and Smyth 2012)
## a proportion of total variability (Vallejos, Marioni, and Richardson 2015)
## Some of these methods are available in scran – for example, see DM or technicalCV2 for calculations based on the 
## coefficient of variation. Here, we use the variance of the log-expression values because the log-transformation 
## protects against genes with strong expression in only one or two cells. This ensures that the set of top HVGs is 
## not dominated by genes with (mostly uninteresting) outlier expression patterns.
## log转换的目的是不使variance收到少数离群值的影响。

################################# 5. Advanced modelling of the technical noise ################################

#----------------------# Trend fitting when spike-ins are unavailable #----------------------#

# 如果没有使用spike-in或者使用的spike-in的量不对，我们可以使用一个替代方案，即fit the trend to the variance estimates of the 
# endogenous genes. 我们通过在trendVar函数中设定use.spikes=FALSE参数进行设定。
# Loading the saved object.

var.fit.nospike <- trendVar(sce.hsc, parametric=TRUE, 
                            use.spikes=FALSE, loess.args=list(span=0.2))
var.out.nospike <- decomposeVar(sce.hsc, var.fit.nospike)
## 如何来进行结果的解释呢？我们最简单的一个解释就是大部分基因的变异并不是来自于差异表达。这就意味着technical component决定了
## 基因表达variance的大部分成分。也就是说我们fitted trend可以认为是technical component的估计值。在下图中，我们看到trend和spike-in
## 的variance是非常接近，或者说前者是穿过后者的，这也证明了我们的假设的正确性。
plot(var.out.nospike$mean, var.out.nospike$total, pch=16, cex=0.6, 
     xlab="Mean log-expression", ylab="Variance of log-expression")
curve(var.fit.nospike$trend(x), col="dodgerblue", lwd=2, add=TRUE)
points(var.out.nospike$mean[cur.spike], var.out.nospike$total[cur.spike], col="red", pch=16)
## Variance of normalized log-expression values for each gene in the 416B dataset, plotted against the mean log-expression
## The blue line represents the mean-dependent trend fitted to the variances of the endogenous genes (black), with spike-in transcripts shown in red.

## 下面这句话要好好理解一下，尤其是从instead开始的部分：
## If our assumption does not hold, the output of decomposeVar is more difficult to interpret. The fitted value of 
## the trend can no longer be generally interpreted as the technical component, as it contains some biological variation 
## as well. Instead, recall that the biological component reported by decomposeVar represents the residual for each 
## gene over the majority of genes with the same abundance. One could assume that the variabilities of most genes are 
## driven by constitutive “house-keeping” processes, which are biological in origin but generally uninteresting. Any 
## gene with an increase in its variance is relatively highly variable and can be prioritized for further study.


#----------------------# Blocking on uninteresting factors of variation #----------------------#
# 使用block=这个参数：
# 根据block后面的参数进行分组，分别fit mean and variance，然后fitting a single trend to the plate-specific means and variance of all
# spike-in transcripts. 我们的假设是两个plate中细胞的trend（between mean and variance）应该是一致的。

sce.416B <- readRDS("416B_data.rds") 

# Repeating the trendVar() call.
var.fit <- trendVar(sce.416B, parametric=TRUE, block=sce.416B$Plate,
                    loess.args=list(span=0.3))

matplot(var.fit$means, var.fit$vars, col=c("darkorange", "forestgreen"))
## Plate-specific variance estimates for all spike-in transcripts in the 416B dataset, plotted against the plate-specific means
## Each point represents a spike-in transcript, numbered by the plate from which the values were estimated.

# 我们使用block=还有一个前提假设，即不同的plate的内源基因的丰度是差不多可比的。我们可以通过观察两个plate的内源基因的size factor
# 的分布情况来说明。
tmp.416B <- sce.416B
tmp.416B$log_size_factor <- log(sizeFactors(sce.416B))
plotColData(tmp.416B, x="Plate", y="log_size_factor")
## Plate-specific distribution of the size factors for endogenous genes
## However, these assumptions may not hold for other datasets. For example, if more spike-in RNA is added in a particular 
## batch, the technical noise (and thus the trend) will decrease due to increased coverage. The mean log-expression of the 
## spike-ins would also shift relative to the endogenous genes in that batch. The use of a single trend would subsequently 
## be inappropriate, resulting in inaccurate estimates of the technical component for each gene.



# fitting batch-specific trends，针对一项研究有多个batch的情况
# For datasets containing multiple batches, an alternative strategy is to perform trend fitting and variance decomposition 
# separately for each batch. This accommodates differences in the mean-variance trends between batches, especially if a different 
# amount of spike-in RNA was added to the cells in each batch. We demonstrate this approach by treating each plate in the 416B 
# dataset as a different batch, using the multiBlockVar() function. This yields plate-specific estimates of the biological and 
# technical components for each gene.
sce.416B.2 <- normalize(sce.416B, size_factor_grouping=sce.416B$Plate)
comb.out <- multiBlockVar(sce.416B.2, block=sce.416B.2$Plate,
                          trend.args=list(parametric=TRUE, loess.args=list(span=0.4)))

# Statistics are combined across multiple batches using the combineVar() function within  multiBlockVar(). This function computes 
# a weighted average across batches for the means and variances, and applies Fisher’s method for combining the p-values. These 
# results can be used in downstream functions such as denoisePCA, or for detecting highly variable genes (see below).
head(comb.out[,1:6])

# We visualize the quality of the batch-specific trend fits by extracting the relevant statistics from comb.out (Figure 9).
par(mfrow=c(1,2))
is.spike <- isSpike(sce.416B.2)
for (plate in levels(sce.416B.2$Plate)) {
  cur.out <- comb.out$per.block[[plate]]
  plot(cur.out$mean, cur.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
       ylab="Variance of log-expression", main=plate)
  curve(metadata(cur.out)$trend(x), col="dodgerblue", lwd=2, add=TRUE)
  points(cur.out$mean[is.spike], cur.out$total[is.spike], col="red", pch=16)
}
## We visualize the quality of the batch-specific trend fits by extracting the relevant statistics from comb.out (Figure 9).
## By fitting separate trends, we avoid the need to assume that a single trend is present across batches. However, this also 
## reduces the precision of each trend fit, as less information is available within each batch. We recommend using block= as 
## the default unless there is clear evidence for differences in the trends between batches.

## We run normalize() with size_factor_grouping= to centre the size factors within each level of the blocking factor. This 
## adjusts the size factors across cells in each batch so that the mean is equal to 1, for both the spike-in and gene-based 
## sets of size factors. Log-normalized expression values are then recalculated using these centred size factors. This procedure 
## ensures that the average abundances of the spike-in transcripts are comparable to the endogenous genes, avoiding problems 
## due to differences in the quantity of spike-in RNA between batches. Otherwise, if the globally-centred size factors were used, 
## there would be a systematic difference in the scaling of spike-in transcripts compared to endogenous genes. The fitted trend 
## would then be shifted along the x-axis and fail to accurately capture the technical component for each gene.

# Using the design= argument
# For completeness, it is worth mentioning the design= argument in trendVar(). This will estimate the residual variance from a 
# linear model fitted to the log-normalized expression values for each gene. The linear model can include blocking factors for 
# known unwanted factors of variation, ensuring that they do not inflate the variance estimate. The technical component for each 
# gene is obtained at the average abundance across all cells.
lfit <- trendVar(sce.416B, design=model.matrix(~sce.416B$Plate))
## We do not recommend using this approach for categorical blocking factors in one-way layouts. This is because it does not consider 
## the mean of each blocking level, resulting in an inaccurate estimate of the technical component in the presence of a strong blocking 
## effect. However, it is the only choice for dealing with real covariates or multiple blocking factors in an additive model.



######################### 6. Identifying correlated gene pairs with Spearman’s rho #########################
# 单细胞转录组分析的另一个用处是考察基因表达谱之间的correlation。我们可以计算spearman相关系数。
# 为了演示，我们选取HSC数据集中的HLA分子，使用correlatePairs函数来找到显著性的correlation。 我们使用permutation的方法
# 来判断显著性，对任意一对基因，零假设是两个基因的表达是相互独立的。我们通过shuffling 表达值，每次shuffle都会计算correlation
# 其最终会形成一个NULL distribution，我们根据这个NULL distribution来计算我们实际观察到的correlation的p-value。
set.seed(100)
var.cor <- correlatePairs(sce.hsc, subset.row=grep("^H2-", rownames(sce.hsc)))
head(var.cor)

# 针对multiple testing，使用FDR为0.05.
sig.cor <- var.cor$FDR <= 0.05
summary(sig.cor)

# 我们使用函数即可以计算制定的一对基因的correlation，也可以计算两个基因set中的所有gene对的correlation
# 我们以组成AP-1的Fos和Jun基因为例：
correlatePairs(sce.hsc, subset.row=cbind("Fos", "Jun"))

# 我们通过下图能够看到两个基因之间存在中等程度的正相关。
plotExpression(sce.hsc, features="Fos", x="Jun")
##  Expression of Fos plotted against the expression of Jun for all cells in the HSC dataset

## Aaron建议只选取感兴趣的gene集进行correlation test，比如HVG，不然结果的解释很难，有多重假设检验的问题，会产生
## 很多uninteresting correlation

## The correlatePairs function can also return gene-centric output by setting  per.gene=TRUE. This calculates a 
## combined p-value (Simes 1986) for each gene that indicates whether it is significantly correlated to any other 
## gene. From a statistical perspective, this is a more natural approach to correcting for multiple testing when 
## genes, rather than pairs of genes, are of interest.

## The Limited field indicates whether the p-value was lower-bounded by the number of permutations. If this is TRUE 
## for any non-significant gene at the chosen FDR threshold, consider increasing the number of permutations to improve 
## power.

######################### 7. Using parallel analysis to choose the number of PCs #########################
# 对于PC的选择，多少个为好呢？我们可以使用parallelPCA函数，它基于permutation，重复计算PCA来评估每个PC所能解释的
# variance。重复的permutation可以让每个PC得到p-values，那些相比于零假设不能解释更多的variance的PC会被舍弃。

# This is demonstrated using the batch-corrected expression values from the 416B dataset. To focus on relevant 
# features, we only use genes with positive biological components from the variability analysis above. This 
# procedure relies on random permutations, so setting the random seed is necessary for reproducible results.
set.seed(1000)
npcs <- parallelPCA(sce.416B, assay.type="corrected", 
                    subset.row=comb.out$bio > 0, value="n")
as.integer(npcs)

## 基于parallel的方法的优势：
## Parallel analysis tends to yield more accurate estimates of the true rank of the matrix than  denoisePCA(). It 
## is also applicable to expression values that have been transformed such that the gene-wise variances are distorted 
## (and thus denoisePCA() cannot be used). This means that parallel analysis can be used to choose the number of PCs 
## after certain non-linear operations like batch correction (Haghverdi et al. 2018). However, it is obviously much 
## slower that denoisePCA() due to the need for multiple permutations.


################################### 8. Blocking on the cell cycle phase ###################################
# 对于研究其他的生物学问题的时候，细胞周期往往不是研究人员感兴趣的内容。然而细胞周期相关基因的表达可能会影响
# 甚至掩盖其它生物学效应，并最终影响结果的解释。这还无法单一通过去除细胞周期marker gene来解除影响，这是因为
# 这些细胞周期会影响到相当多其它的转录本。因此我们需要一个更加复杂的分析策略，我们使用TH2细胞的来作为一个演示
# 这边数据已经经过了QC，normalization和log转换。
library(readxl)
incoming <- as.data.frame(read_excel("nbt.3102-S7.xlsx", sheet=1))
rownames(incoming) <- incoming[,1]
incoming <- incoming[,-1]
incoming <- incoming[,!duplicated(colnames(incoming))] # Remove duplicated genes.
sce.th2 <- SingleCellExperiment(list(logcounts=t(incoming)))

# 我们使用cyclone来鉴定不同的细胞所处于的细胞周期状态。大部分的细胞处在G1期，少部分细胞位于其它期。
library(org.Mm.eg.db)
library(scran)
ensembl <- mapIds(org.Mm.eg.db, keys=rownames(sce.th2), keytype="SYMBOL", column="ENSEMBL")

set.seed(100)
mm.pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", 
                                package="scran"))
assignments <- cyclone(sce.th2, mm.pairs, gene.names=ensembl, assay.type="logcounts")

plot(assignments$score$G1, assignments$score$G2M, 
     xlab="G1 score", ylab="G2/M score", pch=16)
## Cell cycle phase scores from applying the pair-based classifier on the TH2 dataset, where each point represents a cell

# 我们可以根据phase score对细胞进行过滤，这种方法会不那么武断。The phase covariates in the design matrix will absorb any 
# phase-related effects on expression such that they will not affect estimation of the effects of other experimental factors.
# Users should also ensure that the phase score is not confounded with other factors of interest. For example, model fitting 
# is not possible if all cells in one experimental condition are in one phase, and all cells in another condition are in a 
# different phase. 这是增加了batch effect。

design <- model.matrix(~ G1 + G2M, assignments$score)
fit.block <- trendVar(sce.th2, design=design, parametric=TRUE, use.spikes=NA)
dec.block <- decomposeVar(sce.th2, fit.block)

library(limma)
sce.th2.block <- sce.th2
assay(sce.th2.block, "corrected") <- removeBatchEffect(
  logcounts(sce.th2), covariates=design[,-1])

sce.th2.block <- denoisePCA(sce.th2.block, technical=dec.block, 
                            assay.type="corrected")
dim(reducedDim(sce.th2.block, "PCA"))

# Blocking的结果可以通过PCA来展现。在去除cell cycle的情况下，细胞在PC1和PC2上的分布与G1和G2/M期的打分高度相关；在去除cell cycle
# 效应后，这种相关性就不存在了。
sce.th2$G1score <- sce.th2.block$G1score <- assignments$score$G1
sce.th2$G2Mscore <- sce.th2.block$G2Mscore <- assignments$score$G2M

# Without blocking on phase score.
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
fit <- trendVar(sce.th2, parametric=TRUE, use.spikes=NA) 
sce.th2 <- denoisePCA(sce.th2, technical=fit$trend)
out <- plotReducedDim(sce.th2, use_dimred="PCA", ncomponents=2, colour_by="G1score", 
                      size_by="G2Mscore") + fontsize + ggtitle("Before removal")

# After blocking on the phase score.
out2 <- plotReducedDim(sce.th2.block, use_dimred="PCA", ncomponents=2, 
                       colour_by="G1score", size_by="G2Mscore") + fontsize + 
  ggtitle("After removal")
multiplot(out, out2, cols=2)
## PCA plots before (left) and after (right) removal of the cell cycle effect in the TH2 dataset
## Each cell is represented by a point with colour and size determined by the G1 and G2/M scores, respectively.

# 另外，这个数据集中包含了处在分化发育不同阶段的好几种细胞，这是使用diffusion maps的绝佳情景，因为diffusion maps
# 作为一种数据降维方法，把细胞投射到一个连续的process上头去。我们看到细胞分布在一个低维空间的轨迹上面。diffusion的
# 第一个成分看起来能够对应于TH2细胞的分化，这是因为TH2的关键基因Gata3的表达量随着dimension1发生从左到右有规律并
# 符合生物学情景的变化。
plotDiffusionMap(sce.th2.block, colour_by="Gata3",
                 run_args=list(use_dimred="PCA", sigma=25)) + fontsize # 我们倾向于使用larger sigma。
plotDiffusionMap(sce.th2.block, colour_by="Gata3",
                 run_args=list(use_dimred="PCA", sigma=5)) + fontsize
## A diffusion map for the TH2 dataset, where each cell is coloured by its expression of Gata3
## A larger sigma is used compared to the default value to obtain a smoother plot.


#==============================================================================================
#
#          4. Correcting batch effects in single-cell RNA-seq data 重点使用mnnCorrect()
#
#==============================================================================================

################################### 1. Introduction 简介 ###################################
# 比较大的scRNA-seq往往数据是来源于不同批次的测序数据。不同的批次存在一些不可控的因素导致批次之间存在系统性的误差
# 比如操作人员不是同一个人，不同的批次使用的试剂的质量有差别等等。批次效应是导致数据出现异质性的主要原因，会掩盖
# 真正的生物学差异，或者导致结果难以正确解读。

# 采用计算校正的方法可以尽量减少批次效应带来的不利影响。然而，现有的方法中，比如removeBatchEffect函数假设细胞的组成
# 要么是已知的或者是批次之间是完全一样的。此教程主要是通过mutual nearest neughbours (MNNs) 方法来识别批次效应。
# mnnCorrect()方法并不依赖事先定义好的细胞组成或者要求批次之间的细胞组成相同，它只要求不同批次之间存在一部分细胞是一样
# 的。我们通过三个人的单细胞胰岛数据（different groups and different protocols）来讲解这个方法的使用。

# 注意单个研究就可能涉及到批次效应，但是整合不同的数据，处理批次效应的难度更大，所以我们通过这个案例，即能找到
# 单个研究内的批次效应，也能分析不同研究之间的批次效应。

################################### 2. Processing the different datasets 处理不同的数据集 ###################################

#----------------------# CEL-seq，GSE81076  #----------------------# 

# 加载数据：
# 这个数据集来自Audenardden和Grun的CEL-seq方案，使用了UMI序列和spike-in序列。我们根据上面的GSE序号就能下载数据。
# 这个数据集是比较大的；我们通过使用终端下的less，就能发现基因名和染色体名和整合在一起的，细胞也是一样的。也就是
# 说这个文件包括data和metadata两个部分。
gse81076.df <- read.table("GSE81076_D2_3_7_10_17.txt.gz", sep='\t', 
                          header=TRUE, stringsAsFactors=FALSE, row.names=1)
dim(gse81076.df)

# 因为data和metadata是mixed together的，所以我们需要人工的从column name（列名）中提取metadata
head(names(gse81076.df))
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse81076.df))  # 不难发现我们的donor.names是有D和后面的一串数字构成了
table(donor.names)

plate.id <- sub("^D[0-9]+(.*)_.*", "\\1", colnames(gse81076.df)) # 不难发现plate.id是由donor.names和_之间的英文构成的
table(plate.id)

# 另一个比较棘手的事情是feature name在这边采用的是gene symbol，而不是非常唯一可靠的emsembl gene id。 我们将row name
# 全部用ensembl gene id来进行替换，去除NA和重复的entry（spike-in例外）
head(row.names(gse81076.df))
gene.symb <- gsub("__chr.*$", "", rownames(gse81076.df)) # 去除了染色体的信息
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)
head(gene.symb)

library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse81076.df <- gse81076.df[keep,]
rownames(gse81076.df) <- gene.ids[keep]
summary(keep)
gse81076.df[1:6,1:6]
dim(gse81076.df) # 原先的dimension是20148，1728

# 然后我们构建SingleCellExperiment对象并分别存储counts和metadata
# This reduces the risk of book-keeping errors in later steps of the analysis. Note that we re-identify the spike-in 
# rows, as the previous indices would have changed after the subsetting.
library(SingleCellExperiment)
sce.gse81076 <- SingleCellExperiment(list(counts=as.matrix(gse81076.df)),
                                     colData=DataFrame(Donor=donor.names, Plate=plate.id),
                                     rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse81076, "ERCC") <- grepl("^ERCC-", rownames(gse81076.df)) 
sce.gse81076 


# QC和normalization
# 我们计算每个细胞的QC metrics并找到那些测序文库比较低，表达的基因数比较少和高ERCC比例的细胞（低质量细胞）
library(scater)
sce.gse81076 <- calculateQCMetrics(sce.gse81076, compact=TRUE)
QC <- sce.gse81076$scater_qc   # QC metrics存储在scater_qc这个slot当中
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
           HighSpike=sum(high.spike, na.rm=TRUE))

# 我们排除QC metrics当中处于极端情况的细胞，这些细胞我们认为是低质量细胞并且应该被移除。当然一个更好的方法是
# 实现查看这个QC metrics的分布，我们为了简单化这个workflow就跳过这一步。
discard <- low.lib | low.genes | high.spike
sce.gse81076 <- sce.gse81076[,!discard]
summary(discard)

# 我们使用deconvoluted的方法计算内源基因的size factor，这是使用quickCluster()函数来实现，好处是避免把非常不一样的
# 细胞给pool到一起去（不同的cluster分别计算其对应的size factor）。
library(scran)
clusters <- quickCluster(sce.gse81076, min.mean=0.1)
table(clusters)

sce.gse81076 <- computeSumFactors(sce.gse81076, min.mean=0.1, clusters=clusters)
summary(sizeFactors(sce.gse81076))

# 我们也计算spike-in的size factor，注意我们需要将参数general.use = FALSE，这样能够确保计算得到的spike-in的size factor
# 仅仅针对spike-in序列
sce.gse81076 <- computeSpikeFactors(sce.gse81076, general.use=FALSE)
summary(sizeFactors(sce.gse81076, "ERCC"))

# 然后我们可以计算normalized log-expression value，这个结果可以用于后续的计算
sce.gse81076
sce.gse81076 <- normalize(sce.gse81076)
sce.gse81076


# 发现HVG：
# 我们使用trendVar()和decomposeVar()函数来寻找HVG。这样做的好处是通过spike-in的variance能够模拟technical noise。我们设置
# block= 来确保不同plate和donor的不感兴趣的差异并不会增大variance。 
# The small discrepancy in the fitted trend in Figure 1 is caused by the fact that the trend is fitted robustly to the 
# block-wise variances of the spike-ins, while the variances shown are averaged across blocks and not robust to outliers.
block <- paste0(sce.gse81076$Plate, "_", sce.gse81076$Donor) # 我们能够察觉到的单个研究内的批次是来源于不同的供体和不同的plate（培养环境）
fit <- trendVar(sce.gse81076, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse81076, fit)
dec
plot(dec$mean, dec$total, xlab="Mean log-expression", 
     ylab="Variance of log-expression", pch=16)
OBis.spike <- isSpike(sce.gse81076)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
## Variance of normalized log-expression values for each gene in the GSE81076 dataset, plotted against the mean log-expression
## The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).

# 我们根据biological component来对gene进行排序，发现排名靠前的是Ins和Gcg
# We order genes by decreasing biological component, revealing some usual suspects such as insulin and glucagon. 
# We will be using this information later when performing feature selection prior to running mnnCorrect().
dec.gse81076 <- dec
dec.gse81076$Symbol <- rowData(sce.gse81076)$Symbol
dec.gse81076 <- dec.gse81076[order(dec.gse81076$bio, decreasing=TRUE),]
head(dec.gse81076)


#----------------------# CEL-seq2, GSE85241 #----------------------# 
# 我们加载第二个数据集，还是来自于audenardden和Nuraro，使用的CEL-seq2方案，使用了UMI序列和spike-in序列
gse85241.df <- read.table("GSE85241_cellsystems_dataset_4donors_updated.csv", 
                          sep='\t', h=TRUE, row.names=1, stringsAsFactors=FALSE)
dim(gse85241.df)
gse85241.df[1:6,1:6]

# 因为来自于同一个课题组，所以数据构架是一样的。同样我们需要拆分metadata
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse85241.df))
table(donor.names)

plate.id <- sub("^D[0-9]+\\.([0-9]+)_.*", "\\1", colnames(gse85241.df))
table(plate.id)

# 同样我们需要将gene symbol改成ensembl gene id，去除NA和重复值
gene.symb <- gsub("__chr.*$", "", rownames(gse85241.df))
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)

library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse85241.df <- gse85241.df[keep,]
rownames(gse85241.df) <- gene.ids[keep]
summary(keep)

# 构建SingleCellExperiment对象，存储data和metadata
sce.gse85241 <- SingleCellExperiment(list(counts=as.matrix(gse85241.df)),
                                     colData=DataFrame(Donor=donor.names, Plate=plate.id),
                                     rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse85241, "ERCC") <- grepl("^ERCC-", rownames(gse85241.df)) 
sce.gse85241 



# QC和normalization
# 同样计算每个细胞的QC metrics并且根据测序文库的大小，检测到的gene数和ERCC的比例过滤掉低质量细胞
sce.gse85241 <- calculateQCMetrics(sce.gse85241, compact=TRUE)
QC <- sce.gse85241$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
           HighSpike=sum(high.spike, na.rm=TRUE))

discard <- low.lib | low.genes | high.spike
sce.gse85241 <- sce.gse85241[,!discard]
summary(discard)

# 分别计算内源基因和spike-in序列的size factor，通过他们来计算校正后的log-normalized expression value
clusters <- quickCluster(sce.gse85241, min.mean=0.1, method="igraph")
table(clusters)

sce.gse85241 <- computeSumFactors(sce.gse85241, min.mean=0.1, clusters=clusters)
summary(sizeFactors(sce.gse85241))

sce.gse85241 <- computeSpikeFactors(sce.gse85241, general.use=FALSE)
summary(sizeFactors(sce.gse85241, "ERCC"))

sce.gse85241 <- normalize(sce.gse85241)

# 找到HVG
block <- paste0(sce.gse85241$Plate, "_", sce.gse85241$Donor)
fit <- trendVar(sce.gse85241, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse85241, fit)
plot(dec$mean, dec$total, xlab="Mean log-expression", 
     ylab="Variance of log-expression", pch=16)
is.spike <- isSpike(sce.gse85241)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
## Variance of normalized log-expression values for each gene in the GSE85241 dataset, plotted against the mean log-expression
## The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).

# 根据biological component来进行排序，发现Ins和Gcg还是高排。
dec.gse85241 <- dec
dec.gse85241$Symbol <- rowData(sce.gse85241)$Symbol
dec.gse85241 <- dec.gse85241[order(dec.gse85241$bio, decreasing=TRUE),]
head(dec.gse85241)


#----------------------# Smart-seq2, E-MTAB-5061  #----------------------#
# 加载数据：
# 我们最后一个数据来源是Sandberg实验室的，SMART-seq2的文库构建方案，包含ERCC spike-in；注意没有UMI序列，因为是全长转录本
# We first read the table into memory, though this requires some effort as the file is even more unconventionally formatted than the two examples above.
setwd('/Users/mijiarui/Nature_Biotechnology_Paper/simpleSingleCell')
unzip("E-MTAB-5061.processed.1.zip")

# Figuring out the number of libraries (-1 for the '#sample').
header <- read.table("pancreas_refseq_rpkms_counts_3514sc.txt", 
                     nrow=1, sep="\t", comment.char="", stringsAsFactors=FALSE)
header[1:6,1:6]
ncells <- ncol(header) - 1L

# Loading only the gene names and the counts.
col.types <- vector("list", ncells*2 + 2)
col.types[1:2] <- "character"
col.types[2+ncells + seq_len(ncells)] <- "integer"
e5601.df <- read.table("pancreas_refseq_rpkms_counts_3514sc.txt", 
                       sep="\t", colClasses=col.types)

# Disentangling the gene names and the counts.
gene.data <- e5601.df[,1:2]
e5601.df <- e5601.df[,-(1:2)]
colnames(e5601.df) <- as.character(header[1,-1])
dim(e5601.df)

# The gene metadata does contains unique GenBank identifiers, but these are transcript-level and concatenated together for 
# each gene. Instead of trying to pull them apart, we perform the symbol-to-Ensembl conversion that was done for the previous 
# datasets.
is.spike <- grepl("^ERCC-", gene.data[,2])
table(is.spike)

library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.data[,1], keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.data[is.spike,2]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
e5601.df <- e5601.df[keep,]
rownames(e5601.df) <- gene.ids[keep]
summary(keep)

# At least the metadata is stored in a separate file, which makes it fairly straightforward to parse. We match the rows to 
# the column names to ensure that the metadata and count table are in the same order.
metadata <- read.table("E-MTAB-5061.sdrf.txt", header=TRUE, 
                       sep="\t", check.names=FALSE, stringsAsFactors=FALSE)
m <- match(colnames(e5601.df), metadata[["Assay Name"]])
stopifnot(all(!is.na(m)))
metadata <- metadata[m,]
donor.id <- metadata[["Characteristics[individual]"]]
table(donor.id)

# 构建SingleCellExperiment对象
sce.e5601 <- SingleCellExperiment(list(counts=as.matrix(e5601.df)),
                                  colData=DataFrame(Donor=donor.id),
                                  rowData=DataFrame(Symbol=gene.data[keep,1]))
isSpike(sce.e5601, "ERCC") <- grepl("^ERCC-", rownames(e5601.df)) 
sce.e5601  


# QC和normalization
# 同前面，我们进行cell QC，除了常规的根据测序文库的大小，检测到的gene数，高ERCC的比例以外，我们还需要找到near-zero spike-in
# counts，这些counts是不能适应于spike-in normalization和technical noise modelling的。
sce.e5601 <- calculateQCMetrics(sce.e5601, compact=TRUE)
QC <- sce.e5601$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3) 
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
low.spike <- isOutlier(QC$feature_control_ERCC$log10_total_counts, type="lower", nmad=2)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
           HighSpike=sum(high.spike, na.rm=TRUE), LowSpike=sum(low.spike))

# Low-quality cells are defined as those with extreme values for these QC metrics and are removed.
discard <- low.lib | low.genes | high.spike | low.spike
sce.e5601 <- sce.e5601[,!discard]
summary(discard)

# 我们分别计算内源和spike-in序列的size factor，注意因为我们使用的SMART-seq2是根据的read counts data，所以我们的filtering的阈值
# 是min.mean=1 来滤除低丰度的gene
clusters <- quickCluster(sce.e5601, min.mean=1, method="igraph")
table(clusters)

sce.e5601 <- computeSumFactors(sce.e5601, min.mean=1, clusters=clusters)
summary(sizeFactors(sce.e5601))

sce.e5601 <- computeSpikeFactors(sce.e5601, general.use=FALSE)
summary(sizeFactors(sce.e5601, "ERCC"))

sce.e5601 <- normalize(sce.e5601)


# 发现HVG：
# We identify highly variable genes (HVGs) using trendVar() and decomposeVar(). Here, we need to fit the mean-variance trend 
# separately to each donor, as the donor-to-donor variation in the mean-variance trend is more pronounced than that in the 
# UMI datasets. This yields one fit for each donor in Figure 3.
donors <- sort(unique(sce.e5601$Donor))
is.spike <- isSpike(sce.e5601)
par(mfrow=c(ceiling(length(donors)/2), 2), 
    mar=c(4.1, 4.1, 2.1, 0.1))
collected <- list()
for (x in unique(sce.e5601$Donor)) {
  current <- sce.e5601[,sce.e5601$Donor==x]
  if (ncol(current)<2L) { next }
  current <- normalize(current)
  fit <- trendVar(current, parametric=TRUE) 
  dec <- decomposeVar(current, fit)
  plot(dec$mean, dec$total, xlab="Mean log-expression",
       ylab="Variance of log-expression", pch=16, main=x)
  points(fit$mean, fit$var, col="red", pch=16)
  curve(fit$trend(x), col="dodgerblue", add=TRUE)
  collected[[x]] <- dec
}
## Variance of normalized log-expression values for each gene in the E-MTAB-5601 dataset, plotted against the mean log-expression
## Each plot corresponds to a donor, where the blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).

# We combine statistics across donors to consolidate them into a single set of results for this study. We then order genes 
# by decreasing biological component. 数据合并，Ins和Gcg依然高排。
dec.e5601 <- do.call(combineVar, collected)
dec.e5601$Symbol <- rowData(sce.e5601)$Symbol
dec.e5601 <- dec.e5601[order(dec.e5601$bio, decreasing=TRUE),]
head(dec.e5601)

################################### 3. Feature selection across batches 在不同的batch当中选择feature ###################################

#----------------------# Chosen 1 #----------------------#

# To obtain a single set of features for batch selection, we take the top 1000 genes with the largest biological components 
# from each batch. The intersection of this set across batches is defined as our feature set for MNN correction.
# 我们对每一个study(batch)的biological component的前1000个gene进行筛选，然后对它们取交集，这些gene是进行MNN correction的batch
# gene。
top.e5601 <- rownames(dec.e5601)[seq_len(1000)]
top.gse85241 <- rownames(dec.gse85241)[seq_len(1000)]
top.gse81076 <- rownames(dec.gse81076)[seq_len(1000)]
chosen <- Reduce(intersect, list(top.e5601, top.gse85241, top.gse81076))

# Adding some gene symbols for interpretation.
symb <- mapIds(org.Hs.eg.db, keys=chosen, keytype="ENSEMBL", column="SYMBOL")
DataFrame(ID=chosen, Symbol=symb)


#----------------------# Chosen 2 #----------------------#

# 使用交集的策略是一个相对比较保守的策略，这要求同一个gene在多个研究/batch中都被认为是HVG才行。因此对于那些不是在所有
# 研究/batch中都出现的cell type的marker gene是不可能出现在其中的。还有一种策略是使用combineVar()函数来计算每个基因在
# 不同的研究/batch中的平均biological component。然后我们可以根据认为控制top多少个gene来认为定义这个feature set的gene。
# Identifying genes that are annotated in all batches.
in.all <- Reduce(intersect, list(rownames(dec.e5601), 
                                 rownames(dec.gse85241), rownames(dec.gse81076)))

# Setting weighted=FALSE so each batch contributes equally.
combined <- combineVar(dec.e5601[in.all,], dec.gse85241[in.all,],
                       dec.gse81076[in.all,], weighted=FALSE)
chosen2 <- rownames(combined)[head(order(combined$bio, decreasing=TRUE), 1000)]


# 我们在这里最终还是选择Chosen 1的方案，尽管它的结果非常的保守，但是我们能够更加focus在那些非常明显的造成biological difference
# 的基因上面（across pancreas cell types）。这样我们可以规避一些在单个研究的内部来自不同供体的，引起不是我们感兴趣的差异的基因。
# 我们做这一步是因为后续的mnnCorrect()并不能够校正这些gene，并且会让后续plot的解释变得复杂化。

# Aaron在这边指出，当然我们可以使用mnnCorrect()在每个研究的内部对batch进行校正，然后再对不同的研究的batch进行校正。不过我们
# 为了简化，还是通过上述的feature selection的方法来减少donor/plate造成的影响。


################################### 4. Performing MNN-based correction 使用MNN方法进行校正 ###################################
# MNN算法的要义：
# Consider a cell aa in batch AA, and identify the cells in batch BB that are nearest neighbours to aa in the expression space defined by 
# the selected features. Repeat this for a cell bb in batch BB, identifying its nearest neighbours in AA. Mutual nearest 
# neighbours are pairs of cells from different batches that belong in each other’s set of nearest neighbours. The reasoning 
# is that MNN pairs represent cells from the same biological state prior to the application of a batch effect - see Haghverdi 
# et al. (2018) for full theoretical details. Thus, the difference between cells in MNN pairs can be used as an estimate of 
# the batch effect, the subtraction of which can yield batch-corrected values.
# 根据选出来的feature gene的表达情况，在batch B中找到与batch A中的某一个细胞最近的细胞；反过来，在batch A中找到与batch B中的
# 某个细胞最近的细胞。

# We apply the mnnCorrect() function to the three batches to remove the batch effect, using the genes in chosen. This 
# involves correcting their expression values so that all cells are comparable in the coordinate system of the first batch. 
# The function returns a set of matrices containing corrected expression values, which we can use in downstream analyses.

# scran中的mnnCorrect方法
original <- list(logcounts(sce.e5601)[chosen,],
                 logcounts(sce.gse81076)[chosen,],
                 logcounts(sce.gse85241)[chosen,])
?do.call
corrected <- do.call(mnnCorrect, c(original, list(k=20, sigma=0.1)))
str(corrected$corrected)
## The k= parameter specifies the number of nearest neighbours to consider when defining MNN pairs. This should be 
## interpreted as the minimum frequency of each cell type or state in each batch. Larger values will improve the 
##  precision of the correction by increasing the number of MNN pairs, at the cost of reducing accuracy by allowing MNN 
## pairs to form between cells of different type.

## The sigma= parameter specifies how much information is shared between MNN pairs when computing the batch effect. 
## Larger values will share more information, approaching a global correction for all cells in the same batch. Smaller 
## values allow the correction to vary across cell types, which may be more accurate but comes at the cost of precision. 
## The default sigma=1 is conservative and favours undercorrection, so lower values may be more suitable in many cases.

## The order of the supplied batches does matter, as the first batch is treated as the reference coordinate system. We 
## suggest setting the largest and/or most heterogeneous batch as the first. This ensures that sufficient MNN pairs will 
## be identified between the first and other batches for stable correction.

# The function also reports the MNN pairs that were identified in each successive batch. This may be useful for 
# trouble-shooting, e.g., to check whether cells independently assigned to the same cell type are correctly identified 
# as MNN pairs.
corrected$pairs



################################### 5. Examining the effect of correction 查看校正后的结果 ###################################
# 我们新建一个SingleCellExperiment对象来存储这些经过校正后的counts，同时包括了不同的batch的信息。
omat <- do.call(cbind, original)
mat <- do.call(cbind, corrected$corrected)
colnames(mat) <- NULL
sce <- SingleCellExperiment(list(original=omat, corrected=mat))
colData(sce)$Batch <- rep(c("e5601", "gse81076", "gse85241"),
                          lapply(corrected$corrected, ncol))
sce

# 我们使用t-SNE plot来查看batch correction后的结果。图左显示的是使用uncorrected data，细胞的分群情况以及不同的batch分到什么群里面
# 图右显示的是经过correction的结果，我们看到来自不同batch的结果混到了一期，这与去除batch effect后的理想结果是一致的。值得注意的是
# Sandberg的数据集似乎仍然在一定程度上与其它的数据集的结果分离。这可能是由于前者使用的是counts data而后两者使用的是UMI序列。
osce <- runTSNE(sce, exprs_values="original", rand_seed=100)
ot <- plotTSNE(osce, colour_by="Batch") + ggtitle("Original")
csce <- runTSNE(sce, exprs_values="corrected", rand_seed=100)
ct <- plotTSNE(csce, colour_by="Batch") + ggtitle("Corrected")
multiplot(ot, ct, cols=2)
## t-SNE plots of the pancreas datasets, before and after MNN correction
## Each point represents a cell and is coloured by the batch of origin.

# We colour by the expression of marker genes for known pancreas cell types to determine whether the correction is biologically 
# sensible. Cells in the same visual cluster express the same marker genes (Figure 5), indicating that the correction maintains 
# separation of cell types.
# 接下来我们查看一下marker gene的分布，正常情况下，一个marker gene应该富集在一个特定的细胞类型，在t-SNE上应该是一团细胞，这样的结果
# （batch correction的结果）才是有意义的。
ct.gcg <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000115263") + ggtitle("Alpha cells (GCG)")
ct.ins <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000254647") + ggtitle("Beta cells (INS)")
ct.sst <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000157005") + ggtitle("Delta cells (SST)")
ct.ppy <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000108849") + ggtitle("PP cells (PPY)")
ct.anxa4 <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000196975") + ggtitle("ANXA4")
ct.epcam <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000119888") + ggtitle("EPCAM")
ct.cftr <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000001626") + ggtitle("CFTR")
multiplot(ct.gcg, ct.ins, ct.sst, ct.ppy, ct.anxa4, ct.epcam, ct.cftr , cols=3)

library(EnsDb.Hsapiens.v86)
HVG_3 <- mapIds(EnsDb.Hsapiens.v86, keys=rownames(csce), 
                   column="SYMBOL", keytype="GENEID")
HVG_3
HVG_3[grep("^V", HVG_3)]

ct.tmem176a <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000002933") + ggtitle("TMEM176A")
ct.tmem176b <- plotTSNE(csce, by_exprs_values="corrected", 
                        colour_by="ENSG00000106565") + ggtitle("TMEM176B")
ct.neurod1 <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000162992") + ggtitle("NEUROD1")
ct.krt19 <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000171345") + ggtitle("KRT19")
ct.aldh1a1 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000165092") + ggtitle("ALDH1A1")
ct.anxa2 <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000182718") + ggtitle("ANXA2")
ct.muc13 <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000173702") + ggtitle("MUC13")
ct.meg3 <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000214548") + ggtitle("MEG3")
ct.neat1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000245532") + ggtitle("NEAT1")
ct.cela3a <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000142789") + ggtitle("CELA3A")
ct.cela3b <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000219073") + ggtitle("CELA3B")
ct.pdx1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000139515") + ggtitle("PDX1")
ct.cdh1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000039068") + ggtitle("CDH1")
ct.ctgf <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000118523") + ggtitle("CTGF")
ct.malat1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000251562") + ggtitle("MALAT1")
ct.hes1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000114315") + ggtitle("HES1")
ct.ahcyl1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000168710") + ggtitle("AHCYL1")
ct.wnt4 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000162552") + ggtitle("WNT4")
ct.onecut2 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000119547") + ggtitle("ONECUT2")
ct.anxa5 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000164111") + ggtitle("ANXA5")
ct.ca12 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000074410") + ggtitle("CA12")
ct.gp2 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000169347") + ggtitle("GP2")
ct.aldh2 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000111275") + ggtitle("ALDH2")
ct.prdx1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000117450") + ggtitle("PRDX1")
ct.ctrc <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000162438") + ggtitle("CTRC")
ct.pcsk1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000175426") + ggtitle("PCSK1")
ct.pcsk2 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000125851") + ggtitle("PCSK2")
ct.itgb1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000150093") + ggtitle("ITGB1")
ct.erbb3 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000065361") + ggtitle("ERBB3")
ct.actb <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000075624") + ggtitle("ACTB")
ct.hla-b <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000234745") + ggtitle("HLA-B")
ct.g6pc2 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000152254") + ggtitle("G6PC2")
ct.chga <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000100604") + ggtitle("chga")
ct.cd44 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000026508") + ggtitle("CD44")
ct.ttr <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000118271") + ggtitle("TTR")
ct.pax6 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000007372") + ggtitle("PAX6")
ct.igfbp7 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000163453") + ggtitle("IGFBP7")
ct.olfm4 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000102837") + ggtitle("OLFM4")
ct.eno1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000074800") + ggtitle("ENO1")
ct.bace2 <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000182240") + ggtitle("BACE2")
ct.myh9 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000100345") + ggtitle("MYH9")
ct.muc1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000185499") + ggtitle("MUC1")
ct.cpa1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000091704") + ggtitle("CPA1")
ct.aqp1 <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000240583") + ggtitle("AQP1")
ct.kiaa1324 <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000116299") + ggtitle("KIAA1324")
ct.gc <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000145321") + ggtitle("GC")
ct.c3 <- plotTSNE(csce, by_exprs_values="corrected", 
                  colour_by="ENSG00000125730") + ggtitle("C3")
ct.cpa2 <- plotTSNE(csce, by_exprs_values="corrected", 
                  colour_by="ENSG00000158516") + ggtitle("CPA2")
ct.aqp3 <- plotTSNE(csce, by_exprs_values="corrected", 
                  colour_by="ENSG00000165272") + ggtitle("AQP3")
ct.sox4 <- plotTSNE(csce, by_exprs_values="corrected", 
                  colour_by="ENSG00000124766") + ggtitle("SOX4")
ct.gdf15 <- plotTSNE(csce, by_exprs_values="corrected", 
                  colour_by="ENSG00000130513") + ggtitle("GDF15")
ct.egr1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000120738") + ggtitle("EGR1")
ct.gdf15 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000130513") + ggtitle("GDF15")
ct.mafb <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000204103") + ggtitle("MAFB")
ct.dlk1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000185559") + ggtitle("DLK1")
ct.krt8 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000170421") + ggtitle("KRT8")
ct.mmp7 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000137673") + ggtitle("MMP7")
ct.cldn4 <- plotTSNE(csce, by_exprs_values="corrected", 
                    colour_by="ENSG00000189143") + ggtitle("CLDN4")
ct.cldn1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000163347") + ggtitle("CLDN1")
ct.pdk4 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000004799") + ggtitle("PDK4")
ct.cpb1 <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000153002") + ggtitle("CPB1")
ct.aldob <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000136872") + ggtitle("ALDOB")
ct.acly <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000131473") + ggtitle("ACLY")
ct.alb <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000163631") + ggtitle("ALB")
ct.col1a1 <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000108821") + ggtitle("COL1A1")
ct.timp2 <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000185215") + ggtitle("TIMP2")
ct.col1a2 <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000164692") + ggtitle("COL1A2")
ct.syt7 <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000011347") + ggtitle("SYT7")
ct.cel <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000170835") + ggtitle("CEL")
ct.crp <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000132693") + ggtitle("CRP")
ct.gad2 <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000136750") + ggtitle("GAD2")
ct.tm4sf4 <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000169903") + ggtitle("TM4SF4")
ct.tm4sf1 <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000169908") + ggtitle("TM4SF1")
ct.timp1 <- plotTSNE(csce, by_exprs_values="corrected", 
                   colour_by="ENSG00000102265") + ggtitle("TIMP1")
ct.ptprn <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000054356") + ggtitle("PTPRN")
ct.ppp1r1a <- plotTSNE(csce, by_exprs_values="corrected", 
                     colour_by="ENSG00000135447") + ggtitle("PPP1R1A")
ct.lgals2 <- plotTSNE(csce, by_exprs_values="corrected", 
                       colour_by="ENSG00000100079") + ggtitle("LGALS2")
ct.lgals3 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000131981") + ggtitle("LGALS3")
ct.lgals4 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000171747") + ggtitle("LGALS4")
ct.slc7a8 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000092068") + ggtitle("SLC7A8")
ct.slc22a17 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000092096") + ggtitle("SLC22A17")
ct.slc7a2 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000003989") + ggtitle("SLC7A2")
ct.slc38a4 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000139209") + ggtitle("SLC38A4")
ct.slc4a4 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000080493") + ggtitle("SLC4A4")
ct.fam102a <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000167106") + ggtitle("FAM102A")
ct.slc4a4 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000080493") + ggtitle("SLC4A4")
ct.atp1a1 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000163399") + ggtitle("ATP1A1")
ct.s100a10 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000197747") + ggtitle("S100A10")
ct.dlk1 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000185559") + ggtitle("DLK1")
ct.ptp4a1 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000112245") + ggtitle("PTP4A1")
ct.slc25a5 <- plotTSNE(csce, by_exprs_values="corrected", 
                      colour_by="ENSG00000005022") + ggtitle("SLC25A5")
ct.kcnq10t1 <- plotTSNE(csce, by_exprs_values="corrected", 
                       colour_by="ENSG00000269821") + ggtitle("KCNQ1OT1")
ct.vamp8 <- plotTSNE(csce, by_exprs_values="corrected", 
                        colour_by="ENSG00000118640") + ggtitle("VAMP8")
ct.vim <- plotTSNE(csce, by_exprs_values="corrected", 
                        colour_by="ENSG00000026025") + ggtitle("VIM")
ct.vgf <- plotTSNE(csce, by_exprs_values="corrected", 
                        colour_by="ENSG00000128564") + ggtitle("VGF")


## t-SNE plots after MNN correction, where each point represents a cell and is coloured by its corrected expression of 
## key marker genes for known cell types in the pancreas


################################### 6. Using the corrected values in downstream analyses 使用校正后的数值进行下游的分析 ###################################
# 我们要清楚经过corrected的value适用于哪些分析
# MNN correction把来自不同batch的所有细胞都放到了同一个坐标系统中。这就意味着corrected values可以被用来定义细胞之间的距离
# 从而进行数据降维和clustering。然而correction并没有保留数据原来的mean-variance relationship，因此我们并不推荐使用corrected
# value来分析细胞的异质性。

# MNN-corrected values总体来说并不适合进行差异基因表达分析，是基于一下几个原因。
# 1）， The default parameters of mnnCorrect() do not return corrected values on the log-scale, but rather 
# a cosine-normalized log-scale. This makes it difficult to interpret the effect size of DE analyses based 
# on the corrected values.

# 2），It is usually inappropriate to perform DE analyses on batch-corrected values, due to the failure to 
# model the uncertainty of the correction. This usually results in loss of type I error control, i.e., more 
# false positives than expected.

# 在单细胞分析当中，大部分的差异基因分析都是在不同的cluster之间或者在trajectory中进行的。我们推荐使用corrected values
# 进行clustering和trajectory分析，把数据转变回原来的log-expression value或者counts来进行差异基因表达分析。batch effect
# 可以在model的时候作为一个blocking factor，这在使用limma或者edgeR都可以方便的实现。

# MNN-correction的迭代处理：
# Finally, the MNN-corrected values can be used for further correction with mnnCorrect(). This is useful in 
# nested experimental designs involving multiple batches within each of multiple studies, much like the pancreas 
# datasets described above. In such cases, it is reasonable to first perform the correction across batches within 
# the same study (where there should be more similar cell types, and thus more MNN pairs). The batch-corrected 
# values for each study can then be supplied to mnnCorrect() to remove batch effects between studies.

# Comments from Aaron:

## The most direct method of blocking on batch is to use an additive model with the batch of origin and the 
## cluster/trajectory as separate factors. However, this assumes that the batch effect is constant for all 
## clusters and/or along the trajectory. This assumption can be eliminated with an interaction model allowing 
## for cluster-specific batch effects.
## Users should set cos.norm.in=FALSE and cos.norm.out=FALSE when supplying  mnnCorrect() with MNN-corrected 
## values. This ensures that the cosine normalization is only applied once, during the first round of MNN 
## correction.











